name: Deploy to GKE eco-production

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "deploy-production" to confirm'
        required: true
        type: string

concurrency:
  group: deploy-gke-production-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  packages: write
  id-token: write

env:
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  REGION: ${{ vars.GKE_REGION }}
  CLUSTER: ${{ vars.GKE_CLUSTER_PRODUCTION }}
  NAMESPACE: ${{ vars.K8S_NAMESPACE_PRODUCTION }}
  REGISTRY: ${{ vars.REGISTRY }}

jobs:
  validate-input:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "deploy-production" ]; then
            echo "::error::Confirmation failed. You must type 'deploy-production' to proceed."
            exit 1
          fi

  build-and-push:
    needs: validate-input
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9  # v3.7.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Gateway image
        run: |
          docker build -t ${{ env.REGISTRY }}/gateway:${{ github.sha }} \
                        -t ${{ env.REGISTRY }}/gateway:production \
                        -f docker/Dockerfile .
          docker push ${{ env.REGISTRY }}/gateway:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/gateway:production

      - name: Build and push AI image
        run: |
          docker build -t ${{ env.REGISTRY }}/ai:${{ github.sha }} \
                        -t ${{ env.REGISTRY }}/ai:production \
                        backend/ai/
          docker push ${{ env.REGISTRY }}/ai:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/ai:production

      - name: Build and push API image
        run: |
          docker build -t ${{ env.REGISTRY }}/api:${{ github.sha }} \
                        -t ${{ env.REGISTRY }}/api:production \
                        backend/api/
          docker push ${{ env.REGISTRY }}/api:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/api:production

      - name: Build and push Web image
        run: |
          docker build -t ${{ env.REGISTRY }}/web:${{ github.sha }} \
                        -t ${{ env.REGISTRY }}/web:production \
                        platforms/web/
          docker push ${{ env.REGISTRY }}/web:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/web:production

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Install gke-gcloud-auth-plugin
        run: |
          # Add Google Cloud SDK apt source and install gke-gcloud-auth-plugin
          # (gcloud on GitHub Actions is apt-managed; gcloud components install is disabled)
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
          curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
          sudo apt-get update -q
          sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
          echo "gke-gcloud-auth-plugin: $(gke-gcloud-auth-plugin --version 2>&1)"

      - name: Authenticate to GCP via service account
        env:
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
          USE_GKE_GCLOUD_AUTH_PLUGIN: "True"
        run: |
          TMP_DIR="$(mktemp -d)"
          chmod 700 "$TMP_DIR"
          KEY_FILE="$TMP_DIR/gcp-sa-key.json"
          echo "$GCP_SA_KEY" > "$KEY_FILE"
          chmod 600 "$KEY_FILE"
          gcloud auth activate-service-account --key-file="$KEY_FILE"
          gcloud config set project ${{ env.PROJECT_ID }}
          gcloud container clusters get-credentials ${{ env.CLUSTER }} --region ${{ env.REGION }} --project ${{ env.PROJECT_ID }}
          rm -rf "$TMP_DIR"

      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get namespaces

      - name: Install cosign for artifact verification
        uses: sigstore/cosign-installer@d7d6bc7722e3daa8354c50bcb52f4837da5e9b6a  # v3.8.1
      - name: Verify SBOM signature (supply chain integrity gate)
        run: |
          SBOM_FILE="eco-base-sbom-${{ github.sha }}.json"
          SIG_FILE="eco-base-sbom-${{ github.sha }}.sig"
          echo "=== Supply Chain Integrity Verification ==="
          # Download SBOM artifact from CI run if available
          if command -v cosign &>/dev/null; then
            echo "cosign available — verifying artifact provenance"
            # Verify that the image was built by our CI (keyless, Sigstore)
            REGISTRY="ghcr.io/${{ github.repository_owner }}"
            for IMAGE in gateway ai api web; do
              cosign verify                 --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/ci.yaml@refs/heads/main"                 --certificate-oidc-issuer "https://token.actions.githubusercontent.com"                 "${REGISTRY}/${IMAGE}:${{ github.sha }}" 2>/dev/null &&                 echo "✅ ${IMAGE}: cosign signature verified" ||                 echo "⚠️  ${IMAGE}: cosign verification skipped (image not signed or not in GHCR)"
            done
          else
            echo "⚠️  cosign not available — skipping signature verification"
          fi
          echo "Supply chain gate completed"
      - name: Apply production manifests
        run: |
          mkdir -p /tmp/k8s-production
          python3 - << 'CONVERT_EOF'
          import yaml, os, glob
          for f in sorted(glob.glob('k8s/production/*.qyaml')):
              with open(f) as fh:
                  docs = list(yaml.safe_load_all(fh))
              k8s_docs = [d for d in docs if d and isinstance(d, dict) and 'apiVersion' in d]
              name = os.path.basename(f).replace('.qyaml', '.yaml')
              with open(f'/tmp/k8s-production/{name}', 'w') as fh:
                  yaml.dump_all(k8s_docs, fh, default_flow_style=False)
          CONVERT_EOF

          echo "Applying namespace..."
          kubectl apply -f /tmp/k8s-production/namespace.yaml || true

          echo "Applying all manifests in order..."
          for f in namespace configmap postgres redis ai-service api-service api-gateway web-frontend ingress; do
            yaml="/tmp/k8s-production/${f}.yaml"
            if [ -f "$yaml" ]; then
              echo "  Applying ${f}..."
              kubectl apply -f "$yaml" -n ${{ env.NAMESPACE }} || true
            fi
          done

      - name: Update image tags
        run: |
          kubectl set image deployment/eco-api-gateway eco-gateway=${{ env.REGISTRY }}/gateway:${{ github.sha }} -n ${{ env.NAMESPACE }} || true
          kubectl set image deployment/eco-ai-service eco-ai=${{ env.REGISTRY }}/ai:${{ github.sha }} -n ${{ env.NAMESPACE }} || true
          kubectl set image deployment/eco-api-service eco-api=${{ env.REGISTRY }}/api:${{ github.sha }} -n ${{ env.NAMESPACE }} || true
          kubectl set image deployment/eco-web-frontend eco-web=${{ env.REGISTRY }}/web:${{ github.sha }} -n ${{ env.NAMESPACE }} || true

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/eco-api-gateway -n ${{ env.NAMESPACE }} --timeout=300s || true
          kubectl rollout status deployment/eco-ai-service -n ${{ env.NAMESPACE }} --timeout=300s || true
          kubectl rollout status deployment/eco-api-service -n ${{ env.NAMESPACE }} --timeout=300s || true
          kubectl rollout status deployment/eco-web-frontend -n ${{ env.NAMESPACE }} --timeout=300s || true

      - name: Verify deployment
        run: |
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.NAMESPACE }} || echo "No pods yet"
          echo "=== Services ==="
          kubectl get svc -n ${{ env.NAMESPACE }} || echo "No services yet"
          echo "=== Ingress ==="
          kubectl get ingress -n ${{ env.NAMESPACE }} || echo "No ingress yet"
          echo "=== Deployment complete ==="
