name: Compliance Report — SOC2 / ISO27001

# eco-base Compliance Automation
# URI: eco-base://github/workflows/compliance-report
#
# Generates monthly compliance evidence reports for:
#   - SOC2 Type II (CC6, CC7, CC8, CC9)
#   - ISO 27001 (A.12, A.14, A.16)
#
# Report covers:
#   - Access control audit (RBAC changes, secret rotations)
#   - CI/CD pipeline integrity (SBOM, cosign, SLSA evidence)
#   - Vulnerability management (Dependabot, Grype findings)
#   - Incident response (drift detections, SLO failures, rollbacks)
#   - Change management (PR merge history, deployment log)

on:
  schedule:
    # First day of every month at 06:00 UTC
    - cron: "0 6 1 * *"
  workflow_dispatch:
    inputs:
      report_period:
        description: "Report period (YYYY-MM, default: last month)"
        required: false
        default: ""
        type: string
      output_format:
        description: "Output format"
        required: false
        default: "markdown"
        type: choice
        options: ["markdown", "json", "both"]

permissions:
  contents: write
  issues: write
  pull-requests: read
  actions: read
  security-events: read

concurrency:
  group: compliance-report
  cancel-in-progress: true

jobs:
  generate-compliance-report:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
    - name: Checkout
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
      with:
        fetch-depth: 0
        token: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}

    - name: Determine report period
      id: period
      run: |
        if [ -n "${{ github.event.inputs.report_period }}" ]; then
          PERIOD="${{ github.event.inputs.report_period }}"
        else
          PERIOD=$(date -d "last month" +%Y-%m 2>/dev/null || date -v-1m +%Y-%m 2>/dev/null || date +%Y-%m)
        fi
        YEAR=$(echo "$PERIOD" | cut -d'-' -f1)
        MONTH=$(echo "$PERIOD" | cut -d'-' -f2)
        START="${YEAR}-${MONTH}-01T00:00:00Z"
        # Last day of month
        NEXT_MONTH=$(date -d "${YEAR}-${MONTH}-01 +1 month" +%Y-%m-01 2>/dev/null || echo "${YEAR}-$((${MONTH#0}+1))-01")
        END="${NEXT_MONTH}T00:00:00Z"
        echo "period=$PERIOD" >> "$GITHUB_OUTPUT"
        echo "start=$START" >> "$GITHUB_OUTPUT"
        echo "end=$END" >> "$GITHUB_OUTPUT"
        echo "Report period: $PERIOD ($START to $END)"

    - name: Collect compliance evidence
      id: collect
      run: |
        PERIOD="${{ steps.period.outputs.period }}"
        START="${{ steps.period.outputs.start }}"
        END="${{ steps.period.outputs.end }}"
        TOKEN="${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}"
        REPO="${{ github.repository }}"

        python3 << PYEOF
        import json, urllib.request, urllib.parse, os, datetime

        token = os.environ.get('GH_TOKEN', '')
        repo = os.environ.get('REPO', '')
        period = os.environ.get('PERIOD', '')
        start = os.environ.get('START', '')
        end = os.environ.get('END', '')

        def gh_api(path, params=None):
            url = f'https://api.github.com/repos/{repo}{path}'
            if params:
                url += '?' + urllib.parse.urlencode(params)
            req = urllib.request.Request(url, headers={
                'Authorization': f'token {token}',
                'Accept': 'application/vnd.github.v3+json',
                'X-GitHub-Api-Version': '2022-11-28',
            })
            try:
                with urllib.request.urlopen(req, timeout=15) as resp:
                    return json.loads(resp.read())
            except Exception as e:
                print(f'API error {path}: {e}')
                return []

        # Collect data
        print(f'Collecting compliance evidence for {period}...')

        # 1. Merged PRs (change management)
        prs = gh_api('/pulls', {'state': 'closed', 'per_page': 100, 'sort': 'updated', 'direction': 'desc'})
        merged_prs = [p for p in (prs if isinstance(prs, list) else [])
                      if p.get('merged_at') and p['merged_at'] >= start and p['merged_at'] < end]

        # 2. Workflow runs (CI/CD integrity)
        runs = gh_api('/actions/runs', {'per_page': 100, 'created': f'{start}..{end}'})
        workflow_runs = runs.get('workflow_runs', []) if isinstance(runs, dict) else []
        ci_runs = [r for r in workflow_runs if r.get('name') in ['eco-base CI/CD', 'CI']]
        ci_success = len([r for r in ci_runs if r.get('conclusion') == 'success'])
        ci_total = len(ci_runs)

        # 3. Security alerts (vulnerability management)
        secret_alerts = gh_api('/secret-scanning/alerts', {'state': 'open', 'per_page': 30})
        open_secrets = len(secret_alerts) if isinstance(secret_alerts, list) else 0

        # 4. Incidents (drift, SLO failures)
        issues = gh_api('/issues', {'state': 'all', 'labels': 'incident,automated', 'per_page': 50})
        incidents = [i for i in (issues if isinstance(issues, list) else [])
                     if i.get('created_at', '') >= start and i.get('created_at', '') < end]
        resolved_incidents = [i for i in incidents if i.get('state') == 'closed']

        # 5. Dependabot alerts
        dep_alerts = gh_api('/dependabot/alerts', {'state': 'open', 'per_page': 30})
        open_deps = len(dep_alerts) if isinstance(dep_alerts, list) else 0

        # Build evidence object
        evidence = {
            'period': period,
            'generated_at': datetime.datetime.utcnow().isoformat() + 'Z',
            'repository': repo,
            'change_management': {
                'merged_prs': len(merged_prs),
                'pr_titles': [p['title'] for p in merged_prs[:20]],
            },
            'ci_cd_integrity': {
                'total_ci_runs': ci_total,
                'successful_runs': ci_success,
                'success_rate_pct': round(ci_success / ci_total * 100, 2) if ci_total > 0 else 100,
            },
            'vulnerability_management': {
                'open_secret_alerts': open_secrets,
                'open_dependabot_alerts': open_deps,
            },
            'incident_response': {
                'total_incidents': len(incidents),
                'resolved_incidents': len(resolved_incidents),
                'mean_time_to_resolve': 'N/A',
            },
            'compliance_controls': {
                'SOC2_CC6': 'Access control — RBAC via Keycloak/Supabase OIDC',
                'SOC2_CC7': 'System monitoring — Prometheus/Grafana SLO tracking',
                'SOC2_CC8': 'Change management — GitOps with PR review gates',
                'SOC2_CC9': 'Risk mitigation — Automated drift detection + rollback',
                'ISO27001_A12': 'Operations security — CI/CD with SBOM + cosign',
                'ISO27001_A14': 'System acquisition — OPA policy enforcement',
                'ISO27001_A16': 'Incident management — Auto-detection + issue tracking',
            },
        }

        with open('/tmp/compliance-evidence.json', 'w') as f:
            json.dump(evidence, f, indent=2)

        print(f'Evidence collected: {len(merged_prs)} PRs, {ci_total} CI runs, {len(incidents)} incidents')
        PYEOF
      env:
        GH_TOKEN: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}
        REPO: ${{ github.repository }}
        PERIOD: ${{ steps.period.outputs.period }}
        START: ${{ steps.period.outputs.start }}
        END: ${{ steps.period.outputs.end }}

    - name: Generate Markdown compliance report
      run: |
        PERIOD="${{ steps.period.outputs.period }}"
        mkdir -p docs/compliance
        python3 tools/ci-validator/generate-compliance-report.py \
          /tmp/compliance-evidence.json \
          "docs/compliance/compliance-${PERIOD}.md"

    - name: Commit compliance report to repo via PR
      env:
        GH_TOKEN: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}
      run: |
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        git add docs/compliance/
        if git diff --cached --quiet; then
          echo "No new compliance report to commit"
        else
          # Best practice: never push directly to main — use PR flow
          PERIOD="${{ steps.period.outputs.period }}"
          BRANCH="bot/compliance-report-${PERIOD}"
          git checkout -b "$BRANCH"
          git commit -m "docs(compliance): add compliance report for ${PERIOD} [skip ci]"
          git push origin "$BRANCH"
          # Create PR and enable auto-merge
          PR_BODY="Automated compliance report for ${PERIOD}. SOC2/ISO27001 readiness. Auto-merges once CI passes."
          PR_URL=$(gh pr create             --title "docs(compliance): compliance report for ${PERIOD}"             --body "$PR_BODY"             --label "automated,bot-pr,compliance"             --base main             --head "$BRANCH")
          echo "Created PR: $PR_URL"
          gh pr merge "$PR_URL" --auto --squash || true
          echo "Auto-merge enabled"
        fi

    - name: Create compliance report issue
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
      with:
        github-token: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const period = '${{ steps.period.outputs.period }}';
          let reportContent = '';
          try {
            reportContent = fs.readFileSync(`docs/compliance/compliance-${period}.md`, 'utf8');
          } catch (e) {
            reportContent = 'Report generation failed — check workflow logs.';
          }

          // Truncate if too long for issue body
          const maxLen = 60000;
          const body = reportContent.length > maxLen
            ? reportContent.substring(0, maxLen) + '\n\n_[Report truncated — see full report in docs/compliance/]_'
            : reportContent;

          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `[Compliance] Monthly Report — ${period}`,
            body: body,
            labels: ['compliance', 'automated', 'soc2', 'iso27001'],
          });
          console.log(`Compliance report issue created for ${period}`);

    - name: Persist compliance metrics to Supabase (long-term audit trail)
      if: always()
      env:
        SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      run: |
        # Persist key metrics to Supabase for >90-day audit window
        # GitHub API only retains 90 days of workflow history; Supabase provides
        # the long-term immutable audit store required for SOC2/ISO27001.
        if [ -z "$SUPABASE_URL" ] || [ -z "$SUPABASE_SERVICE_KEY" ]; then
          echo "⚠️  Supabase not configured — metrics stored in repo only (90-day limit applies)"
          echo "   To enable long-term compliance storage, set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY"
          exit 0
        fi
        python3 << 'PYEOF'
        import os, json, urllib.request, urllib.error
        from datetime import datetime, timezone

        supabase_url = os.environ.get('SUPABASE_URL', '').rstrip('/')
        service_key = os.environ.get('SUPABASE_SERVICE_KEY', '')
        period = os.environ.get('REPORT_PERIOD', datetime.now(timezone.utc).strftime('%Y-%m'))

        if not supabase_url or not service_key:
            print('Supabase not configured — skipping persistence')
            exit(0)

        # Read collected evidence
        evidence_file = '/tmp/compliance-evidence.json'
        if not os.path.exists(evidence_file):
            print('No evidence file found — skipping Supabase persistence')
            exit(0)

        evidence = json.load(open(evidence_file))

        # Build compliance record
        record = {
            'period': period,
            'recorded_at': datetime.now(timezone.utc).isoformat(),
            'workflow_run_id': os.environ.get('GITHUB_RUN_ID', ''),
            'commit_sha': os.environ.get('GITHUB_SHA', ''),
            'evidence': evidence,
            'source': 'github-actions-compliance-report',
        }

        # Upsert to Supabase compliance_records table
        url = f'{supabase_url}/rest/v1/compliance_records'
        data = json.dumps(record).encode()
        req = urllib.request.Request(
            url,
            data=data,
            headers={
                'apikey': service_key,
                'Authorization': f'Bearer {service_key}',
                'Content-Type': 'application/json',
                'Prefer': 'resolution=merge-duplicates',
            },
            method='POST',
        )
        try:
            with urllib.request.urlopen(req, timeout=15) as resp:
                print(f'✅ Compliance record persisted to Supabase for period: {period}')
        except urllib.error.HTTPError as e:
            body = e.read().decode()
            if 'relation "compliance_records" does not exist' in body:
                print('⚠️  compliance_records table not yet created in Supabase.')
                print('   Run: CREATE TABLE compliance_records (period TEXT PRIMARY KEY, recorded_at TIMESTAMPTZ, workflow_run_id TEXT, commit_sha TEXT, evidence JSONB, source TEXT);')
            else:
                print(f'⚠️  Supabase persistence failed: {e.code} {body[:200]}')
        except Exception as e:
            print(f'⚠️  Supabase persistence error: {e}')
        PYEOF
      env:
        REPORT_PERIOD: ${{ steps.period.outputs.period }}
    - name: Upload compliance artifacts
      uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08  # v4.6.2
      if: always()
      with:
        name: compliance-evidence-${{ steps.period.outputs.period }}
        path: |
          /tmp/compliance-evidence.json
          docs/compliance/compliance-${{ steps.period.outputs.period }}.md
        retention-days: 365
