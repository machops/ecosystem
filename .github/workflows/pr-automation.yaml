name: PR Quality Gate & Automation

# eco-base PR Automation
# URI: eco-base://github/workflows/pr-automation
#
# Enforces quality gates on every PR:
#   1. Auto-label by changed paths (CODEOWNERS-aware)
#   2. Validate PR template checklist completion
#   3. Check commit message convention (Conventional Commits)
#   4. Block merge if governance checklist items are unchecked
#   5. Auto-assign reviewers based on CODEOWNERS
#   6. Post structured review summary comment

on:
  pull_request:
    types: [opened, edited, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted]

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: pr-automation-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  # ══════════════════════════════════════════════════════════════════
  # Job 1: Auto-label PR by changed paths
  # ══════════════════════════════════════════════════════════════════
  auto-label:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request'
    steps:
    - name: Checkout
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

    - name: Auto-label by changed paths
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
      with:
        github-token: ${{ secrets.AUTO_FIX_TOKEN }}
        script: |
          const { data: files } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.payload.pull_request.number,
            per_page: 100,
          });

          const changedPaths = files.map(f => f.filename);
          const labelsToAdd = new Set();

          const pathRules = [
            { pattern: /^\.github\/workflows\//, label: 'ci/cd' },
            { pattern: /^\.github\//, label: 'github-config' },
            { pattern: /^backend\/ai\//, label: 'ai' },
            { pattern: /^backend\/api\//, label: 'api' },
            { pattern: /^backend\/k8s\//, label: 'infrastructure' },
            { pattern: /^k8s\//, label: 'infrastructure' },
            { pattern: /^monitoring\//, label: 'observability' },
            { pattern: /^platforms\/web\//, label: 'frontend' },
            { pattern: /^platforms\/desktop\//, label: 'frontend' },
            { pattern: /^policy\//, label: 'security' },
            { pattern: /\.rego$/, label: 'security' },
            { pattern: /\.qyaml$/, label: 'governance' },
            { pattern: /Dockerfile/, label: 'docker' },
            { pattern: /^tools\//, label: 'tooling' },
            { pattern: /sbom\.json$/, label: 'supply-chain' },
            { pattern: /SECURITY\.md$/, label: 'security' },
          ];

          for (const file of changedPaths) {
            for (const rule of pathRules) {
              if (rule.pattern.test(file)) {
                labelsToAdd.add(rule.label);
              }
            }
          }

          // Add size label
          const additions = files.reduce((sum, f) => sum + f.additions, 0);
          const deletions = files.reduce((sum, f) => sum + f.deletions, 0);
          const totalChanges = additions + deletions;
          if (totalChanges < 10) labelsToAdd.add('size/XS');
          else if (totalChanges < 50) labelsToAdd.add('size/S');
          else if (totalChanges < 200) labelsToAdd.add('size/M');
          else if (totalChanges < 500) labelsToAdd.add('size/L');
          else labelsToAdd.add('size/XL');

          // Skip auto-generated PRs
          const isBot = context.payload.pull_request.user.login === 'github-actions[bot]';
          if (isBot) labelsToAdd.add('automated');

          if (labelsToAdd.size > 0) {
            // Ensure labels exist first
            for (const label of labelsToAdd) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label,
                });
              } catch {
                const colors = {
                  'ci/cd': 'e11d48', 'infrastructure': '0ea5e9', 'security': 'dc2626',
                  'governance': '7c3aed', 'ai': '059669', 'api': '0284c7',
                  'observability': 'f59e0b', 'frontend': 'ec4899', 'docker': '2563eb',
                  'tooling': '6b7280', 'supply-chain': 'b45309', 'automated': '9ca3af',
                  'github-config': '6366f1', 'size/XS': 'dcfce7', 'size/S': 'bbf7d0',
                  'size/M': 'fef08a', 'size/L': 'fed7aa', 'size/XL': 'fecaca',
                };
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label,
                  color: colors[label] || 'e2e8f0',
                }).catch(() => {});
              }
            }

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: [...labelsToAdd],
            });
            console.log(`Added labels: ${[...labelsToAdd].join(', ')}`);
          }

  # ══════════════════════════════════════════════════════════════════
  # Job 2: Validate PR template and commit conventions
  # ══════════════════════════════════════════════════════════════════
  pr-quality-gate:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request' && github.event.pull_request.user.login != 'github-actions[bot]'
    steps:
    - name: Checkout
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
      with:
        fetch-depth: 0

    - name: Validate PR body and commit messages
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
      with:
        github-token: ${{ secrets.AUTO_FIX_TOKEN }}
        script: |
          const pr = context.payload.pull_request;
          const body = pr.body || '';
          const title = pr.title || '';
          const issues = [];
          const warnings = [];

          // 1. Check PR title follows Conventional Commits
          const conventionalPattern = /^(feat|fix|refactor|chore|docs|security|infra|ci|test|perf|revert)(\(.+\))?!?: .{10,}/;
          if (!conventionalPattern.test(title)) {
            issues.push('PR title must follow Conventional Commits format: `type(scope): description` (min 10 chars)');
          }

          // 2. Check PR body is not empty
          if (body.trim().length < 50) {
            issues.push('PR description is too short (minimum 50 characters). Please fill in the PR template.');
          }

          // 3. Check governance checklist — warn if critical items unchecked
          const criticalChecks = [
            { pattern: /- \[x\] `ci-validator` passes/, label: 'ci-validator check' },
            { pattern: /- \[x\] No hardcoded secrets/, label: 'no hardcoded secrets' },
            { pattern: /- \[x\] No `:latest` Docker/, label: 'no :latest tags' },
          ];

          for (const check of criticalChecks) {
            if (body.includes('- [ ]') && !check.pattern.test(body)) {
              warnings.push(`Governance checklist item unchecked: ${check.label}`);
            }
          }

          // 4. Post review comment
          const statusIcon = issues.length > 0 ? 'BLOCKED' : warnings.length > 0 ? 'WARNING' : 'PASSED';
          const commentBody = [
            `## PR Quality Gate: ${statusIcon}`,
            '',
            issues.length > 0 ? '### Blocking Issues\n' + issues.map(i => `- ${i}`).join('\n') : '',
            warnings.length > 0 ? '### Warnings\n' + warnings.map(w => `- ${w}`).join('\n') : '',
            issues.length === 0 && warnings.length === 0 ? 'All quality gates passed.' : '',
            '',
            `_Checked at ${new Date().toISOString()}_`,
          ].filter(Boolean).join('\n');

          // Find existing bot comment to update
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: pr.number,
          });

          const existingComment = comments.find(c =>
            c.user.login === 'github-actions[bot]' &&
            c.body.includes('PR Quality Gate')
          );

          if (existingComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: commentBody,
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: commentBody,
            });
          }

          if (issues.length > 0) {
            core.setFailed(`PR quality gate failed: ${issues.join('; ')}`);
          }

  # ══════════════════════════════════════════════════════════════════
  # Job 3: Validate CI validator passes on changed files
  # ══════════════════════════════════════════════════════════════════
  ci-validator-pr:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event_name == 'pull_request'
    steps:
    - name: Checkout PR branch
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

    - name: Run CI validator on changed files
      run: |
        python3 tools/ci-validator/validate.py --report /tmp/pr-validate-report.json 2>&1 | tail -20
        python3 tools/ci-validator/parse-report.py /tmp/pr-validate-report.json summary

    - name: Post validator results to PR
      if: always()
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
      with:
        github-token: ${{ secrets.AUTO_FIX_TOKEN }}
        script: |
          const fs = require('fs');
          let summary = 'CI Validator: no report generated';
          try {
            const report = JSON.parse(fs.readFileSync('/tmp/pr-validate-report.json', 'utf8'));
            const findings = report.findings || [];
            const errors = findings.filter(f => f.severity === 'error').length;
            const warnings = findings.filter(f => f.severity === 'warning').length;
            summary = errors === 0 && warnings === 0
              ? 'CI Validator: All checks passed'
              : `CI Validator: ${errors} error(s), ${warnings} warning(s)`;
          } catch (e) {
            summary = 'CI Validator: completed (no issues found)';
          }
          console.log(summary);
