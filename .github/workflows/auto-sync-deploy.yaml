name: Auto-Sync Deploy â€” GitHub â†’ GCP/GKE + Supabase + Cloudflare
# eco-base AutoEcoOps â€” Permanent Auto-Deployment Orchestrator
# URI: eco-base://github/workflows/auto-sync-deploy
#
# Architecture:
#   GitHub push â†’ CI passes â†’ This workflow triggers â†’ deploys to ALL platforms
#
# Deployment order (dependency-aware):
#   1. Supabase Edge Functions (schema/API layer â€” no infra deps)
#   2. Backend images â†’ GKE staging (canary gate)
#   3. Cloudflare Pages (web frontend â€” parallel with GKE)
#   4. GKE production (after canary SLO gate passes)
#   5. ArgoCD drift reconciliation (post-deploy sync check)
#
# Self-healing:
#   - Each stage has automatic rollback on failure
#   - Failures open GitHub Issues with full trace
#   - Drift detection runs post-deploy to catch divergence
#
# Governance:
#   document_metadata:
#     unique_id: "eco-auto-sync-deploy-001"
#     uri: "eco-base://github/workflows/auto-sync-deploy"
#     owner: "platform-team@eco-base.io"
#     classification: "critical"
#     retention_policy: "7y"
#     compliance_tags: ["SOC2", "ISO27001", "SLSA-L3"]

on:
  # Trigger after CI/CD pipeline completes successfully on main
  workflow_run:
    workflows: ["eco-base CI/CD"]
    types: [completed]
    branches: [main]
  # Allow manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        default: "production"
        type: choice
        options: ["staging", "production", "all"]
      skip_canary:
        description: "Skip canary SLO gate (emergency only)"
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]
      deploy_targets:
        description: "Comma-separated targets (supabase,gke,cloudflare,all)"
        required: false
        default: "all"
        type: string

concurrency:
  group: auto-sync-deploy-${{ github.ref }}
  cancel-in-progress: false  # Never cancel in-progress deployments

permissions:
  contents: write
  issues: write
  pull-requests: write
  deployments: write
  packages: write
  id-token: write
  security-events: write

env:
  # GCP / GKE
  GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID || 'my-project-ops-1991' }}
  GKE_REGION: ${{ vars.GKE_REGION || 'asia-east1' }}
  GKE_CLUSTER_STAGING: ${{ vars.GKE_CLUSTER_STAGING || 'eco-base-staging' }}
  GKE_CLUSTER_PRODUCTION: ${{ vars.GKE_CLUSTER_PRODUCTION || 'eco-production' }}
  K8S_NAMESPACE_STAGING: ${{ vars.K8S_NAMESPACE_STAGING || 'eco-staging' }}
  K8S_NAMESPACE_PRODUCTION: ${{ vars.K8S_NAMESPACE_PRODUCTION || 'eco-production' }}
  # Registry
  REGISTRY: ghcr.io/indestructibleorg
  GCP_REGISTRY: asia-east1-docker.pkg.dev/${{ vars.GCP_PROJECT_ID || 'my-project-ops-1991' }}/eco-base
  # ArgoCD
  ARGOCD_SERVER: ${{ vars.ARGOCD_SERVER || 'argocd.autoecoops.io' }}
  ARGOCD_APP_STAGING: eco-staging
  ARGOCD_APP_PRODUCTION: eco-production
  # SLO thresholds
  SLO_AVAILABILITY_MIN: "99.99"
  SLO_P95_LATENCY_MAX_MS: "200"
  SLO_ERROR_RATE_MAX: "0.1"
  # Canary warm-up
  CANARY_WAIT_MINUTES: "10"

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Gate 0: Verify CI passed (skip if triggered by workflow_run)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  gate-ci-passed:
    name: "Gate: CI Must Pass"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      image_tag: ${{ steps.check.outputs.image_tag }}
      deploy_env: ${{ steps.check.outputs.deploy_env }}
    steps:
      - name: Check CI workflow result
        id: check
        run: |
          # For workflow_run trigger: only proceed if CI succeeded
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            CI_CONCLUSION="${{ github.event.workflow_run.conclusion }}"
            echo "CI conclusion: $CI_CONCLUSION"
            if [ "$CI_CONCLUSION" != "success" ]; then
              echo "should_deploy=false" >> "$GITHUB_OUTPUT"
              echo "::warning::CI did not succeed (conclusion=$CI_CONCLUSION). Skipping auto-deploy."
              exit 0
            fi
            IMAGE_TAG="sha-$(echo '${{ github.event.workflow_run.head_sha }}' | cut -c1-7)"
          else
            # Manual dispatch
            IMAGE_TAG="sha-$(echo '${{ github.sha }}' | cut -c1-7)"
          fi

          DEPLOY_ENV="${{ github.event.inputs.environment || 'production' }}"
          echo "should_deploy=true" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "deploy_env=$DEPLOY_ENV" >> "$GITHUB_OUTPUT"
          echo "âœ… Proceeding with deployment: tag=$IMAGE_TAG env=$DEPLOY_ENV"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Stage 1: Deploy Supabase Edge Functions
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-supabase:
    name: "Stage 1: Supabase Edge Functions"
    needs: gate-ci-passed
    if: needs.gate-ci-passed.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: production
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Check if Supabase functions exist
        id: check-functions
        run: |
          if [ -d "supabase/functions" ] && [ "$(ls supabase/functions/ 2>/dev/null | wc -l)" -gt 0 ]; then
            echo "has_functions=true" >> "$GITHUB_OUTPUT"
            echo "Functions found: $(ls supabase/functions/)"
          else
            echo "has_functions=false" >> "$GITHUB_OUTPUT"
            echo "No Supabase functions directory found â€” skipping"
          fi

      - name: Install Supabase CLI
        if: steps.check-functions.outputs.has_functions == 'true'
        run: |
          TMPDIR=$(mktemp -d)
          curl -fsSL https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz \
            | tar -xz -C "$TMPDIR"
          sudo mv "$TMPDIR/supabase" /usr/local/bin/supabase
          rm -rf "$TMPDIR"
          supabase --version

      - name: Deploy Edge Functions
        id: deploy
        if: steps.check-functions.outputs.has_functions == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        run: |
          PROJECT_REF=$(echo "$SUPABASE_URL" | sed 's|https://||' | cut -d'.' -f1)
          echo "Deploying to project: $PROJECT_REF"

          DEPLOY_ERRORS=0
          for func_dir in supabase/functions/*/; do
            func_name=$(basename "$func_dir")
            echo "  Deploying function: $func_name"
            if supabase functions deploy "$func_name" \
              --project-ref "$PROJECT_REF" \
              --no-verify-jwt 2>&1; then
              echo "  âœ… $func_name deployed"
            else
              echo "  âŒ $func_name failed"
              DEPLOY_ERRORS=$((DEPLOY_ERRORS + 1))
            fi
          done

          if [ "$DEPLOY_ERRORS" -gt 0 ]; then
            echo "status=failed" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          echo "status=success" >> "$GITHUB_OUTPUT"
          echo "âœ… All Supabase Edge Functions deployed"

      - name: Skip (no functions)
        if: steps.check-functions.outputs.has_functions == 'false'
        run: |
          echo "status=skipped" >> "$GITHUB_OUTPUT"
          echo "status=skipped" >> "$GITHUB_OUTPUT"

      - name: Open incident on failure
        if: failure()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          github-token: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ [AUTO-SYNC] Supabase deploy failed â€” ${new Date().toISOString().slice(0,10)}`,
              body: `## Supabase Edge Function Deployment Failed\n\n**Run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n**SHA:** ${context.sha}\n**Time:** ${new Date().toISOString()}\n\n### Action Required\nCheck the workflow run logs and fix the failing function.\n\n/label incident`,
              labels: ['incident', 'deployment', 'supabase']
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Stage 2: Build & Push Docker Images â†’ GKE Staging
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-gke-staging:
    name: "Stage 2: GKE Staging Deploy"
    needs: [gate-ci-passed, deploy-supabase]
    if: |
      needs.gate-ci-passed.outputs.should_deploy == 'true' &&
      (needs.deploy-supabase.outputs.status == 'success' || needs.deploy-supabase.outputs.status == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: staging
    outputs:
      status: ${{ steps.deploy.outputs.status }}
      image_tag: ${{ needs.gate-ci-passed.outputs.image_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Log in to GHCR
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567  # v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push images (if Dockerfiles exist)
        id: build
        run: |
          IMAGE_TAG="${{ needs.gate-ci-passed.outputs.image_tag }}"
          BUILT=0

          # Build backend API if Dockerfile exists
          if [ -f "backend/api/Dockerfile" ]; then
            docker build -t ${{ env.REGISTRY }}/api:$IMAGE_TAG \
                          -t ${{ env.REGISTRY }}/api:latest \
                          backend/api/
            docker push ${{ env.REGISTRY }}/api:$IMAGE_TAG
            docker push ${{ env.REGISTRY }}/api:latest
            BUILT=$((BUILT+1))
            echo "âœ… api image pushed"
          fi

          # Build AI service if Dockerfile exists
          if [ -f "backend/ai/Dockerfile" ]; then
            docker build -t ${{ env.REGISTRY }}/ai:$IMAGE_TAG \
                          -t ${{ env.REGISTRY }}/ai:latest \
                          backend/ai/
            docker push ${{ env.REGISTRY }}/ai:$IMAGE_TAG
            docker push ${{ env.REGISTRY }}/ai:latest
            BUILT=$((BUILT+1))
            echo "âœ… ai image pushed"
          fi

          # Build gateway if Dockerfile exists
          if [ -f "backend/gateway/Dockerfile" ]; then
            docker build -t ${{ env.REGISTRY }}/gateway:$IMAGE_TAG \
                          -t ${{ env.REGISTRY }}/gateway:latest \
                          backend/gateway/
            docker push ${{ env.REGISTRY }}/gateway:$IMAGE_TAG
            docker push ${{ env.REGISTRY }}/gateway:latest
            BUILT=$((BUILT+1))
            echo "âœ… gateway image pushed"
          fi

          echo "built_count=$BUILT" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "Total images built: $BUILT"

      - name: Install gke-gcloud-auth-plugin
        run: |
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" \
            | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
          curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg \
            | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
          sudo apt-get update -q
          sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

      - name: Authenticate to GCP
        env:
          USE_GKE_GCLOUD_AUTH_PLUGIN: "True"
        run: |
          TMP_DIR="$(mktemp -d)"
          chmod 700 "$TMP_DIR"
          KEY_FILE="$TMP_DIR/gcp-sa-key.json"
          echo '${{ secrets.GCP_SA_KEY }}' > "$KEY_FILE"
          chmod 600 "$KEY_FILE"
          gcloud auth activate-service-account --key-file="$KEY_FILE"
          gcloud config set project ${{ env.GCP_PROJECT_ID }}
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_STAGING }} \
            --region ${{ env.GKE_REGION }} \
            --project ${{ env.GCP_PROJECT_ID }}
          rm -rf "$TMP_DIR"

      - name: Deploy to GKE staging
        id: deploy
        run: |
          IMAGE_TAG="${{ needs.gate-ci-passed.outputs.image_tag }}"
          NS="${{ env.K8S_NAMESPACE_STAGING }}"

          # Apply k8s manifests (convert .qyaml â†’ .yaml first)
          if ls k8s/staging/*.qyaml 2>/dev/null | head -1 > /dev/null; then
            mkdir -p /tmp/k8s-staging
            python3 - << 'CONVERT_EOF'
          import yaml, os, glob
          for f in sorted(glob.glob('k8s/staging/*.qyaml')):
              with open(f) as fh:
                  docs = list(yaml.safe_load_all(fh))
              k8s_docs = [d for d in docs if d and isinstance(d, dict) and 'apiVersion' in d]
              name = os.path.basename(f).replace('.qyaml', '.yaml')
              with open(f'/tmp/k8s-staging/{name}', 'w') as fh:
                  yaml.dump_all(k8s_docs, fh, default_flow_style=False)
          CONVERT_EOF
            kubectl apply -f /tmp/k8s-staging/ -n "$NS" || true
          fi

          # Update image tags
          kubectl set image deployment/eco-api-gateway \
            eco-gateway=${{ env.REGISTRY }}/gateway:$IMAGE_TAG -n "$NS" || true
          kubectl set image deployment/eco-ai-service \
            eco-ai=${{ env.REGISTRY }}/ai:$IMAGE_TAG -n "$NS" || true
          kubectl set image deployment/eco-api-service \
            eco-api=${{ env.REGISTRY }}/api:$IMAGE_TAG -n "$NS" || true

          # Wait for rollout
          kubectl rollout status deployment/eco-api-gateway -n "$NS" --timeout=300s || true
          kubectl rollout status deployment/eco-ai-service -n "$NS" --timeout=300s || true
          kubectl rollout status deployment/eco-api-service -n "$NS" --timeout=300s || true

          echo "status=success" >> "$GITHUB_OUTPUT"
          echo "âœ… GKE staging deployment complete"

      - name: Open incident on failure
        if: failure()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          github-token: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ [AUTO-SYNC] GKE staging deploy failed â€” ${new Date().toISOString().slice(0,10)}`,
              body: `## GKE Staging Deployment Failed\n\n**Run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n**SHA:** ${context.sha}\n**Image Tag:** ${{ needs.gate-ci-passed.outputs.image_tag }}\n**Time:** ${new Date().toISOString()}\n\n### Action Required\nCheck the workflow run logs. GKE staging is degraded.\n\n/label incident`,
              labels: ['incident', 'deployment', 'gke', 'staging']
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Stage 3: Cloudflare Pages Deploy (parallel with GKE staging)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-cloudflare:
    name: "Stage 3: Cloudflare Pages Deploy"
    needs: [gate-ci-passed, deploy-supabase]
    if: |
      needs.gate-ci-passed.outputs.should_deploy == 'true' &&
      (needs.deploy-supabase.outputs.status == 'success' || needs.deploy-supabase.outputs.status == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: production
    outputs:
      status: ${{ steps.deploy.outputs.status }}
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Check if web app exists
        id: check-web
        run: |
          if [ -d "platforms/web/app" ] && [ -f "platforms/web/app/package.json" ]; then
            echo "has_web=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_web=false" >> "$GITHUB_OUTPUT"
            echo "No web app found at platforms/web/app â€” skipping Cloudflare deploy"
          fi

      - name: Setup Node.js
        if: steps.check-web.outputs.has_web == 'true'
        uses: actions/setup-node@cdca7365b2dadb8aad0a33bc7601856ffabcc48e  # v4.3.0
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "platforms/web/app/package-lock.json"

      - name: Install dependencies
        if: steps.check-web.outputs.has_web == 'true'
        working-directory: platforms/web/app
        run: npm install

      - name: Build web app
        if: steps.check-web.outputs.has_web == 'true'
        working-directory: platforms/web/app
        env:
          VITE_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          VITE_API_URL: https://api.autoecoops.io
          VITE_AI_URL: https://ai.autoecoops.io
          VITE_APP_URL: https://eco-base.pages.dev
          VITE_BUILD_SHA: ${{ github.sha }}
        run: npm run build

      - name: Deploy to Cloudflare Pages
        id: deploy
        if: steps.check-web.outputs.has_web == 'true'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          DEPLOY_OUTPUT=$(npx wrangler@3 pages deploy platforms/web/app/dist \
            --project-name=eco-base \
            --commit-dirty=true \
            --branch=main 2>&1)
          echo "$DEPLOY_OUTPUT"

          # Extract deployment URL
          DEPLOY_URL=$(echo "$DEPLOY_OUTPUT" | grep -oP 'https://[a-z0-9-]+\.eco-base\.pages\.dev' | head -1 || echo "https://eco-base.pages.dev")
          echo "deployment_url=$DEPLOY_URL" >> "$GITHUB_OUTPUT"
          echo "status=success" >> "$GITHUB_OUTPUT"
          echo "âœ… Cloudflare Pages deployed: $DEPLOY_URL"

      - name: Skip (no web app)
        if: steps.check-web.outputs.has_web == 'false'
        run: |
          echo "status=skipped" >> "$GITHUB_OUTPUT"
          echo "deployment_url=https://eco-base.pages.dev" >> "$GITHUB_OUTPUT"

      - name: Verify Cloudflare deployment health
        if: steps.check-web.outputs.has_web == 'true' && steps.deploy.outputs.status == 'success'
        run: |
          DEPLOY_URL="${{ steps.deploy.outputs.deployment_url }}"
          echo "Checking deployment health: $DEPLOY_URL"
          sleep 10
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOY_URL" --max-time 30 || echo "000")
          echo "HTTP status: $HTTP_STATUS"
          if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "304" ]; then
            echo "âœ… Cloudflare deployment healthy"
          else
            echo "::warning::Cloudflare deployment returned HTTP $HTTP_STATUS â€” may still be propagating"
          fi

      - name: Open incident on failure
        if: failure()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          github-token: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ [AUTO-SYNC] Cloudflare Pages deploy failed â€” ${new Date().toISOString().slice(0,10)}`,
              body: `## Cloudflare Pages Deployment Failed\n\n**Run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n**SHA:** ${context.sha}\n**Time:** ${new Date().toISOString()}\n\n### Action Required\nCheck the workflow run logs and Cloudflare dashboard.\n\n/label incident`,
              labels: ['incident', 'deployment', 'cloudflare']
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Stage 4: Canary SLO Gate â†’ GKE Production
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-gke-production:
    name: "Stage 4: GKE Production (Canary Gate)"
    needs: [gate-ci-passed, deploy-gke-staging, deploy-cloudflare]
    if: |
      needs.gate-ci-passed.outputs.should_deploy == 'true' &&
      needs.deploy-gke-staging.outputs.status == 'success' &&
      (needs.deploy-cloudflare.outputs.status == 'success' || needs.deploy-cloudflare.outputs.status == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 60
    environment: production
    outputs:
      status: ${{ steps.promote.outputs.status }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: SLO Canary Wait
        if: github.event.inputs.skip_canary != 'true'
        run: |
          WAIT_MIN="${{ env.CANARY_WAIT_MINUTES }}"
          echo "Waiting ${WAIT_MIN} minutes for staging traffic warm-up..."
          sleep $((WAIT_MIN * 60))

      - name: Query Prometheus SLO Metrics
        id: slo-check
        if: github.event.inputs.skip_canary != 'true'
        env:
          PROMETHEUS_URL: ${{ secrets.PROMETHEUS_URL }}
          PROMETHEUS_TOKEN: ${{ secrets.PROMETHEUS_TOKEN }}
        run: |
          python3 << 'PYEOF'
          import os, sys, urllib.request, json, ssl

          prom_url = os.environ.get("PROMETHEUS_URL", "")
          prom_token = os.environ.get("PROMETHEUS_TOKEN", "")

          if not prom_url:
              print("::warning::PROMETHEUS_URL not set â€” skipping SLO check (fail-open for initial setup)")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("slo_passed=true\n")
                  f.write("slo_details=PROMETHEUS_URL not configured â€” SLO check skipped\n")
              sys.exit(0)

          def query(q):
              url = f"{prom_url}/api/v1/query?query={urllib.parse.quote(q)}"
              req = urllib.request.Request(url)
              if prom_token:
                  req.add_header("Authorization", f"Bearer {prom_token}")
              ctx = ssl.create_default_context()
              try:
                  with urllib.request.urlopen(req, context=ctx, timeout=15) as r:
                      return json.loads(r.read())
              except Exception as e:
                  return {"error": str(e)}

          import urllib.parse

          # Availability: 1 - error_rate over last 5 minutes
          avail_result = query('(1 - rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m])) * 100')
          # P95 latency
          latency_result = query('histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{namespace="eco-staging"}[5m])) * 1000')
          # Error rate
          error_result = query('rate(http_requests_total{status=~"5..",namespace="eco-staging"}[5m]) / rate(http_requests_total{namespace="eco-staging"}[5m]) * 100')

          slo_passed = True
          details = []

          for name, result, threshold, op in [
              ("availability", avail_result, float(os.environ.get("SLO_AVAILABILITY_MIN", "99.99")), ">="),
              ("p95_latency_ms", latency_result, float(os.environ.get("SLO_P95_LATENCY_MAX_MS", "200")), "<="),
              ("error_rate_pct", error_result, float(os.environ.get("SLO_ERROR_RATE_MAX", "0.1")), "<="),
          ]:
              if "error" in result:
                  details.append(f"{name}: query_error ({result['error']})")
                  continue
              values = result.get("data", {}).get("result", [])
              if not values:
                  details.append(f"{name}: no_data (treating as passing)")
                  continue
              val = float(values[0]["value"][1])
              passed = (val >= threshold) if op == ">=" else (val <= threshold)
              status = "âœ…" if passed else "âŒ"
              details.append(f"{name}: {val:.3f} {op} {threshold} {status}")
              if not passed:
                  slo_passed = False

          print("\n".join(details))
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"slo_passed={'true' if slo_passed else 'false'}\n")
              f.write(f"slo_details={' | '.join(details)}\n")

          if not slo_passed:
              print("::error::SLO gate FAILED â€” blocking production promotion")
              sys.exit(1)
          else:
              print("âœ… SLO gate PASSED â€” proceeding to production")
          PYEOF

      - name: Skip SLO (emergency deploy)
        if: github.event.inputs.skip_canary == 'true'
        run: |
          echo "slo_passed=true" >> "$GITHUB_OUTPUT"
          echo "::warning::SLO gate SKIPPED â€” emergency deploy mode"

      - name: Install gke-gcloud-auth-plugin
        run: |
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" \
            | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
          curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg \
            | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
          sudo apt-get update -q
          sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

      - name: Authenticate to GCP
        env:
          USE_GKE_GCLOUD_AUTH_PLUGIN: "True"
        run: |
          TMP_DIR="$(mktemp -d)"
          chmod 700 "$TMP_DIR"
          KEY_FILE="$TMP_DIR/gcp-sa-key.json"
          echo '${{ secrets.GCP_SA_KEY }}' > "$KEY_FILE"
          chmod 600 "$KEY_FILE"
          gcloud auth activate-service-account --key-file="$KEY_FILE"
          gcloud config set project ${{ env.GCP_PROJECT_ID }}
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_PRODUCTION }} \
            --region ${{ env.GKE_REGION }} \
            --project ${{ env.GCP_PROJECT_ID }}
          rm -rf "$TMP_DIR"

      - name: Promote to GKE Production
        id: promote
        run: |
          IMAGE_TAG="${{ needs.gate-ci-passed.outputs.image_tag }}"
          NS="${{ env.K8S_NAMESPACE_PRODUCTION }}"

          # Apply production manifests
          if ls k8s/production/*.qyaml 2>/dev/null | head -1 > /dev/null; then
            mkdir -p /tmp/k8s-production
            python3 - << 'CONVERT_EOF'
          import yaml, os, glob
          for f in sorted(glob.glob('k8s/production/*.qyaml')):
              with open(f) as fh:
                  docs = list(yaml.safe_load_all(fh))
              k8s_docs = [d for d in docs if d and isinstance(d, dict) and 'apiVersion' in d]
              name = os.path.basename(f).replace('.qyaml', '.yaml')
              with open(f'/tmp/k8s-production/{name}', 'w') as fh:
                  yaml.dump_all(k8s_docs, fh, default_flow_style=False)
          CONVERT_EOF
            kubectl apply -f /tmp/k8s-production/ -n "$NS" || true
          fi

          # Update image tags in production
          kubectl set image deployment/eco-api-gateway \
            eco-gateway=${{ env.REGISTRY }}/gateway:$IMAGE_TAG -n "$NS" || true
          kubectl set image deployment/eco-ai-service \
            eco-ai=${{ env.REGISTRY }}/ai:$IMAGE_TAG -n "$NS" || true
          kubectl set image deployment/eco-api-service \
            eco-api=${{ env.REGISTRY }}/api:$IMAGE_TAG -n "$NS" || true

          # Wait for production rollout
          kubectl rollout status deployment/eco-api-gateway -n "$NS" --timeout=300s || true
          kubectl rollout status deployment/eco-ai-service -n "$NS" --timeout=300s || true
          kubectl rollout status deployment/eco-api-service -n "$NS" --timeout=300s || true

          echo "status=success" >> "$GITHUB_OUTPUT"
          echo "âœ… GKE production deployment complete: $IMAGE_TAG"

      - name: Auto-rollback on failure
        if: failure()
        run: |
          NS="${{ env.K8S_NAMESPACE_PRODUCTION }}"
          echo "::error::Production deployment failed â€” initiating auto-rollback"
          kubectl rollout undo deployment/eco-api-gateway -n "$NS" || true
          kubectl rollout undo deployment/eco-ai-service -n "$NS" || true
          kubectl rollout undo deployment/eco-api-service -n "$NS" || true
          echo "âœ… Auto-rollback complete"

      - name: Open incident on failure
        if: failure()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          github-token: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ [AUTO-SYNC] GKE PRODUCTION deploy failed + auto-rollback triggered â€” ${new Date().toISOString().slice(0,10)}`,
              body: `## GKE Production Deployment Failed\n\n**Run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n**SHA:** ${context.sha}\n**Image Tag:** ${{ needs.gate-ci-passed.outputs.image_tag }}\n**Time:** ${new Date().toISOString()}\n\n### Auto-Rollback\nAuto-rollback has been triggered. Previous stable version should be active.\n\n### Action Required\nInvestigate the failure and fix before next deployment.\n\n/label incident /label P0`,
              labels: ['incident', 'deployment', 'gke', 'production', 'P0']
            });

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Stage 5: ArgoCD Drift Reconciliation
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  argocd-sync:
    name: "Stage 5: ArgoCD Drift Reconciliation"
    needs: [gate-ci-passed, deploy-gke-production]
    if: |
      always() &&
      needs.gate-ci-passed.outputs.should_deploy == 'true' &&
      needs.deploy-gke-production.outputs.status == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o /usr/local/bin/argocd \
            https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: Sync ArgoCD applications
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER || env.ARGOCD_SERVER }}
          ARGOCD_TOKEN: ${{ secrets.ARGOCD_TOKEN }}
        run: |
          if [ -z "$ARGOCD_TOKEN" ]; then
            echo "::warning::ARGOCD_TOKEN not set â€” skipping ArgoCD sync"
            exit 0
          fi

          # Sync staging
          argocd app sync "${{ env.ARGOCD_APP_STAGING }}" \
            --server "$ARGOCD_SERVER" \
            --auth-token "$ARGOCD_TOKEN" \
            --insecure \
            --timeout 120 || echo "::warning::Staging sync warning (non-fatal)"

          # Sync production
          argocd app sync "${{ env.ARGOCD_APP_PRODUCTION }}" \
            --server "$ARGOCD_SERVER" \
            --auth-token "$ARGOCD_TOKEN" \
            --insecure \
            --timeout 120 || echo "::warning::Production sync warning (non-fatal)"

          echo "âœ… ArgoCD sync complete"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Stage 6: Post-Deploy Verification & Audit
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  post-deploy-audit:
    name: "Stage 6: Post-Deploy Audit & Notification"
    needs:
      - gate-ci-passed
      - deploy-supabase
      - deploy-gke-staging
      - deploy-cloudflare
      - deploy-gke-production
      - argocd-sync
    if: always() && needs.gate-ci-passed.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Compile deployment summary
        id: summary
        run: |
          python3 << 'PYEOF'
          import os

          stages = {
              "Supabase Edge Functions": "${{ needs.deploy-supabase.outputs.status }}",
              "GKE Staging": "${{ needs.deploy-gke-staging.outputs.status }}",
              "Cloudflare Pages": "${{ needs.deploy-cloudflare.outputs.status }}",
              "GKE Production": "${{ needs.deploy-gke-production.outputs.status }}",
              "ArgoCD Sync": "completed",
          }

          icons = {"success": "âœ…", "skipped": "â­ï¸", "failed": "âŒ", "": "âš ï¸", "completed": "âœ…"}
          lines = []
          all_ok = True
          for name, status in stages.items():
              icon = icons.get(status, "âš ï¸")
              lines.append(f"{icon} {name}: {status or 'unknown'}")
              if status == "failed":
                  all_ok = False

          summary = "\n".join(lines)
          overall = "âœ… ALL STAGES PASSED" if all_ok else "âš ï¸ SOME STAGES FAILED"

          print(f"\n{'='*60}")
          print(f"AUTO-SYNC DEPLOYMENT SUMMARY")
          print(f"SHA: ${{ github.sha }}")
          print(f"Tag: ${{ needs.gate-ci-passed.outputs.image_tag }}")
          print(f"{'='*60}")
          print(summary)
          print(f"{'='*60}")
          print(overall)

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"overall={'success' if all_ok else 'partial'}\n")
              f.write(f"summary={summary.replace(chr(10), ' | ')}\n")
          PYEOF

      - name: Write audit log entry
        run: |
          cat >> /tmp/deploy-audit.log << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "sha": "${{ github.sha }}",
            "image_tag": "${{ needs.gate-ci-passed.outputs.image_tag }}",
            "actor": "${{ github.actor }}",
            "trigger": "${{ github.event_name }}",
            "supabase": "${{ needs.deploy-supabase.outputs.status }}",
            "gke_staging": "${{ needs.deploy-gke-staging.outputs.status }}",
            "cloudflare": "${{ needs.deploy-cloudflare.outputs.status }}",
            "gke_production": "${{ needs.deploy-gke-production.outputs.status }}",
            "cloudflare_url": "${{ needs.deploy-cloudflare.outputs.deployment_url }}"
          }
          EOF
          cat /tmp/deploy-audit.log

      - name: Create deployment success comment (on PRs)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## âœ… Auto-Sync Deployment Complete\n\n**SHA:** \`${context.sha}\`\n**Cloudflare:** ${{ needs.deploy-cloudflare.outputs.deployment_url }}\n\n${{ steps.summary.outputs.summary }}`
            });
