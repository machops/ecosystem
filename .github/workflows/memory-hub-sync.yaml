name: Memory Hub Sync

# eco-base Memory Hub Synchronization
# URI: eco-base://github/workflows/memory-hub-sync
#
# Triggers vector index updates in Memory Hub (pgvector) whenever:
#   - Policy files (.rego) change
#   - Governance documents (.qyaml, .md) change
#   - Architecture documents change
#   - API schemas (OpenAPI/AsyncAPI) change
#
# Architecture reference:
#   Memory Hub = pgvector + Embeddings (文件切片、向量檢索、RAG 上下文)
#   All platforms query Memory Hub for context before processing requests.
#
# Flow:
#   1. Detect changed document files
#   2. Chunk documents into segments
#   3. POST to Memory Hub /api/v1/ingest endpoint
#   4. Verify embedding was created
#   5. Report sync status

on:
  push:
    branches: [main]
    paths:
      - "policy/**/*.rego"
      - "**/*.qyaml"
      - "docs/**/*.md"
      - "GOVERNANCE.md"
      - "SECURITY.md"
      - "README.md"
      - "ecosystem/**/*.yaml"
      - "backend/api/src/**/*.ts"
      - "k8s/**/*.yaml"
      - "monitoring/**/*.yaml"
  workflow_dispatch:
    inputs:
      sync_scope:
        description: "Scope of sync"
        required: false
        default: "changed"
        type: choice
        options: ["changed", "all-policy", "all-docs", "full"]
      dry_run:
        description: "Dry run (detect changes only, do not sync)"
        required: false
        default: "false"
        type: choice
        options: ["true", "false"]

permissions:
  contents: read
  issues: write

concurrency:
  group: memory-hub-sync
  cancel-in-progress: true

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      has_changes: ${{ steps.detect.outputs.has_changes }}
      changed_files: ${{ steps.detect.outputs.changed_files }}
      file_count: ${{ steps.detect.outputs.file_count }}
    steps:
    - name: Checkout
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
      with:
        fetch-depth: 2

    - name: Detect changed document files
      id: detect
      run: |
        SCOPE="${{ github.event.inputs.sync_scope || 'changed' }}"

        if [ "$SCOPE" = "changed" ]; then
          # Get files changed in the last commit
          CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '\.(rego|qyaml|md|yaml)$' | head -50 || echo "")
        elif [ "$SCOPE" = "all-policy" ]; then
          CHANGED=$(find policy/ -name "*.rego" | head -50)
        elif [ "$SCOPE" = "all-docs" ]; then
          CHANGED=$(find docs/ -name "*.md" | head -50)
        else
          # full: all document types
          CHANGED=$(find . -name "*.rego" -o -name "*.qyaml" | grep -v node_modules | grep -v .git | head -100)
        fi

        COUNT=$(echo "$CHANGED" | grep -c . || echo "0")

        if [ -z "$CHANGED" ] || [ "$COUNT" = "0" ]; then
          echo "has_changes=false" >> "$GITHUB_OUTPUT"
          echo "file_count=0" >> "$GITHUB_OUTPUT"
          echo "changed_files=" >> "$GITHUB_OUTPUT"
          echo "No document changes detected"
        else
          echo "has_changes=true" >> "$GITHUB_OUTPUT"
          echo "file_count=$COUNT" >> "$GITHUB_OUTPUT"
          # Encode as comma-separated for output
          ENCODED=$(echo "$CHANGED" | tr '\n' ',' | sed 's/,$//')
          echo "changed_files=$ENCODED" >> "$GITHUB_OUTPUT"
          echo "Detected $COUNT changed files:"
          echo "$CHANGED"
        fi

  sync-to-memory-hub:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    steps:
    - name: Checkout
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

    - name: Chunk and sync documents to Memory Hub
      id: sync
      run: |
        DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"
        MEMORY_HUB_URL="${{ secrets.MEMORY_HUB_URL }}"
        MEMORY_HUB_TOKEN="${{ secrets.MEMORY_HUB_TOKEN }}"
        CHANGED_FILES="${{ needs.detect-changes.outputs.changed_files }}"

        if [ -z "$MEMORY_HUB_URL" ]; then
          echo "MEMORY_HUB_URL not configured — skipping sync (Memory Hub not deployed)"
          echo "sync_status=skipped" >> "$GITHUB_OUTPUT"
          echo "synced_count=0" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        python3 << 'PYEOF'
        import os, json, urllib.request, urllib.error, hashlib, re

        memory_hub_url = os.environ.get('MEMORY_HUB_URL', '').rstrip('/')
        token = os.environ.get('MEMORY_HUB_TOKEN', '')
        changed_files_str = os.environ.get('CHANGED_FILES', '')
        dry_run = os.environ.get('DRY_RUN', 'false').lower() == 'true'
        repo = os.environ.get('GITHUB_REPOSITORY', 'unknown')
        sha = os.environ.get('GITHUB_SHA', 'unknown')[:8]

        files = [f.strip() for f in changed_files_str.split(',') if f.strip()]
        print(f'Processing {len(files)} files (dry_run={dry_run})')

        synced = 0
        failed = 0
        skipped = 0

        for filepath in files:
            if not os.path.exists(filepath):
                print(f'  SKIP (not found): {filepath}')
                skipped += 1
                continue

            try:
                with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
                    content = f.read()
            except Exception as e:
                print(f'  SKIP (read error): {filepath}: {e}')
                skipped += 1
                continue

            # Determine document type and URI
            ext = os.path.splitext(filepath)[1]
            if ext == '.rego':
                doc_type = 'policy'
            elif ext == '.qyaml':
                doc_type = 'governance'
            elif ext == '.md':
                doc_type = 'documentation'
            else:
                doc_type = 'configuration'

            uri = f'eco-base://{repo}/{filepath}'
            doc_id = hashlib.sha256(uri.encode()).hexdigest()[:16]

            # Chunk document (max 1000 chars per chunk with overlap)
            chunk_size = 1000
            overlap = 100
            chunks = []
            for i in range(0, len(content), chunk_size - overlap):
                chunk = content[i:i + chunk_size]
                if chunk.strip():
                    chunks.append({
                        'chunk_index': len(chunks),
                        'content': chunk,
                        'char_start': i,
                        'char_end': i + len(chunk),
                    })

            payload = {
                'document_id': doc_id,
                'uri': uri,
                'type': doc_type,
                'filepath': filepath,
                'repository': repo,
                'commit_sha': sha,
                'chunks': chunks,
                'metadata': {
                    'file_size': len(content),
                    'chunk_count': len(chunks),
                    'language': ext.lstrip('.'),
                },
            }

            if dry_run:
                print(f'  DRY-RUN: {filepath} -> {len(chunks)} chunks, uri={uri}')
                synced += 1
                continue

            # POST to Memory Hub
            try:
                data = json.dumps(payload).encode('utf-8')
                req = urllib.request.Request(
                    f'{memory_hub_url}/api/v1/ingest',
                    data=data,
                    headers={
                        'Authorization': f'Bearer {token}',
                        'Content-Type': 'application/json',
                        'X-Source': 'github-actions',
                        'X-Commit': sha,
                    },
                    method='POST',
                )
                with urllib.request.urlopen(req, timeout=30) as resp:
                    result = json.loads(resp.read())
                    print(f'  SYNCED: {filepath} -> {len(chunks)} chunks, embedding_id={result.get("embedding_id", "?")}')
                    synced += 1
            except urllib.error.HTTPError as e:
                print(f'  FAILED: {filepath}: HTTP {e.code} {e.reason}')
                failed += 1
            except Exception as e:
                print(f'  FAILED: {filepath}: {e}')
                failed += 1

        print(f'\nSync complete: {synced} synced, {failed} failed, {skipped} skipped')

        # Write outputs
        with open(os.environ.get('GITHUB_OUTPUT', '/dev/null'), 'a') as f:
            f.write(f'synced_count={synced}\n')
            f.write(f'failed_count={failed}\n')
            f.write(f'sync_status={"success" if failed == 0 else "partial"}\n')

        if failed > 0:
            exit(1)
        PYEOF
      env:
        MEMORY_HUB_URL: ${{ secrets.MEMORY_HUB_URL }}
        MEMORY_HUB_TOKEN: ${{ secrets.MEMORY_HUB_TOKEN }}
        CHANGED_FILES: ${{ needs.detect-changes.outputs.changed_files }}
        DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}

    - name: Report sync status
      if: always()
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const status = '${{ steps.sync.outputs.sync_status }}' || 'unknown';
          const synced = '${{ steps.sync.outputs.synced_count }}' || '0';
          const fileCount = '${{ needs.detect-changes.outputs.file_count }}';
          const sha = context.sha.substring(0, 8);

          const statusIcon = status === 'success' ? 'synced' : status === 'skipped' ? 'skipped (not configured)' : 'partial failure';
          console.log(`Memory Hub Sync: ${statusIcon} — ${synced}/${fileCount} files synced (commit ${sha})`);

          // Only create issue on failure
          if (status === 'partial' || status === 'failed') {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[Memory Hub] Sync failure — commit ${sha}`,
              body: `Memory Hub sync failed for commit ${sha}.\n\nFiles attempted: ${fileCount}\nFiles synced: ${synced}\n\n**Retry**: Re-run this workflow manually after Memory Hub recovers.\n\nCheck workflow logs: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              labels: ['memory-hub', 'automated', 'incident', 'retry-queue'],
            });
          }
