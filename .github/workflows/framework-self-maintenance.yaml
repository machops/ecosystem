name: Framework Self-Maintenance â€” Health, Integrity & Auto-Repair
# eco-base AutoEcoOps â€” Self-Maintaining Framework
# URI: eco-base://github/workflows/framework-self-maintenance
#
# This workflow ensures the automation framework itself remains healthy.
# It runs on schedule and after every deployment to verify:
#   1. All 34 workflow files are valid YAML
#   2. All validator strategies have matching auto-fix implementations
#   3. All required GitHub secrets are present (names only, not values)
#   4. Dependabot is active and not stalled
#   5. No new security alerts have appeared
#   6. Auto-fix framework can still create PRs (idempotency check)
#   7. Drift detection is running on schedule
#
# If any check fails, it:
#   - Opens a GitHub Issue with full diagnostic details
#   - Attempts auto-repair where possible
#   - Sends a structured audit log entry
#
# Governance:
#   document_metadata:
#     unique_id: "eco-framework-self-maintenance-001"
#     uri: "eco-base://github/workflows/framework-self-maintenance"
#     owner: "platform-team@eco-base.io"
#     classification: "critical"
#     retention_policy: "7y"
#     compliance_tags: ["SOC2", "ISO27001"]

on:
  # Run daily at 06:00 UTC (14:00 HKT)
  schedule:
    - cron: "0 6 * * *"
  # Run after every deployment
  workflow_run:
    workflows: ["Auto-Sync Deploy â€” GitHub â†’ GCP/GKE + Supabase + Cloudflare"]
    types: [completed]
  # Manual trigger for on-demand health check
  workflow_dispatch:
    inputs:
      repair_mode:
        description: "Attempt auto-repair on failures"
        required: false
        default: "true"
        type: choice
        options: ["true", "false"]

concurrency:
  group: framework-self-maintenance-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  security-events: read

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Check 1: Workflow File Integrity
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  check-workflow-integrity:
    name: "Check: Workflow File Integrity"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      status: ${{ steps.check.outputs.status }}
      details: ${{ steps.check.outputs.details }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Validate all workflow YAML files
        id: check
        run: |
          python3 << 'PYEOF'
          import yaml, os, sys

          workflows_dir = ".github/workflows"
          errors = []
          warnings = []
          checked = 0

          REQUIRED_WORKFLOWS = [
              "auto-fix-ci.yaml",
              "auto-sync-deploy.yaml",
              "framework-self-maintenance.yaml",
              "ci.yaml",
              "security-scan.yaml",
              "drift-detection.yaml",
              "compliance-report.yaml",
              "canary-deploy.yaml",
          ]

          for f in sorted(os.listdir(workflows_dir)):
              if not f.endswith((".yaml", ".yml")):
                  continue
              path = os.path.join(workflows_dir, f)
              checked += 1
              try:
                  d = yaml.safe_load(open(path).read())
                  if not d:
                      warnings.append(f"{f}: empty document")
                  elif not isinstance(d, dict):
                      warnings.append(f"{f}: not a mapping")
                  elif "jobs" not in d:
                      warnings.append(f"{f}: no jobs defined")
              except yaml.YAMLError as e:
                  errors.append(f"{f}: YAML error â€” {e}")

          # Check required workflows exist
          existing = set(os.listdir(workflows_dir))
          for req in REQUIRED_WORKFLOWS:
              if req not in existing:
                  errors.append(f"MISSING required workflow: {req}")

          status = "failed" if errors else ("warning" if warnings else "success")
          details_parts = []
          if errors:
              details_parts.append("ERRORS: " + "; ".join(errors))
          if warnings:
              details_parts.append("WARNINGS: " + "; ".join(warnings))
          if not errors and not warnings:
              details_parts.append(f"All {checked} workflows valid")

          details = " | ".join(details_parts)
          print(f"Status: {status}")
          print(f"Checked: {checked} files")
          if errors:
              for e in errors: print(f"  ERROR: {e}")
          if warnings:
              for w in warnings: print(f"  WARN: {w}")

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"status={status}\n")
              f.write(f"details={details}\n")

          if errors:
              sys.exit(1)
          PYEOF

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Check 2: Auto-Fix Strategy Coverage
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  check-strategy-coverage:
    name: "Check: Auto-Fix Strategy Coverage"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      status: ${{ steps.check.outputs.status }}
      details: ${{ steps.check.outputs.details }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Verify all validator strategies have auto-fix implementations
        id: check
        run: |
          python3 << 'PYEOF'
          import re, sys

          validate_content = open("tools/ci-validator/validate.py").read()
          autofix_content = open("tools/ci-validator/auto-fix.py").read()

          # Extract strategies referenced in validate.py
          validate_strategies = set(re.findall(
              r'["\']fix_strategy["\']\s*[:=]\s*["\']([^"\']+)["\']',
              validate_content
          ))

          # Extract strategies implemented in auto-fix.py
          autofix_strategies = set(re.findall(
              r'@register_fix\(["\']([^"\']+)["\']',
              autofix_content
          ))

          missing = validate_strategies - autofix_strategies
          extra = autofix_strategies - validate_strategies

          print(f"Validate strategies ({len(validate_strategies)}): {sorted(validate_strategies)}")
          print(f"Auto-fix strategies ({len(autofix_strategies)}): {sorted(autofix_strategies)}")

          if missing:
              print(f"MISSING implementations: {sorted(missing)}")
              with open(os.environ["GITHUB_OUTPUT"] if 'GITHUB_OUTPUT' in __import__('os').environ else '/dev/null', "a") as f:
                  f.write(f"status=failed\n")
                  f.write(f"details=Missing auto-fix strategies: {', '.join(sorted(missing))}\n")
              sys.exit(1)
          else:
              import os
              with open(os.environ.get("GITHUB_OUTPUT", "/dev/null"), "a") as f:
                  f.write(f"status=success\n")
                  f.write(f"details=All {len(validate_strategies)} strategies covered. Extra implementations: {len(extra)}\n")
              print(f"âœ… All {len(validate_strategies)} strategies have implementations")
          PYEOF

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Check 3: Required Secrets Presence (names only, not values)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  check-secrets-presence:
    name: "Check: Required Secrets Configured"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      status: ${{ steps.check.outputs.status }}
      details: ${{ steps.check.outputs.details }}
    steps:
      - name: Verify required secrets are set
        id: check
        env:
          # Test each secret by checking if it's non-empty
          HAS_GCP_SA_KEY: ${{ secrets.GCP_SA_KEY != '' }}
          HAS_CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN != '' }}
          HAS_CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID != '' }}
          HAS_SUPABASE_URL: ${{ secrets.SUPABASE_URL != '' }}
          HAS_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY != '' }}
          HAS_SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY != '' }}
          HAS_AUTO_FIX_TOKEN: ${{ secrets.AUTO_FIX_TOKEN != '' }}
        run: |
          python3 << 'PYEOF'
          import os

          checks = {
              "GCP_SA_KEY": os.environ.get("HAS_GCP_SA_KEY", "false") == "true",
              "CLOUDFLARE_API_TOKEN": os.environ.get("HAS_CLOUDFLARE_API_TOKEN", "false") == "true",
              "CLOUDFLARE_ACCOUNT_ID": os.environ.get("HAS_CLOUDFLARE_ACCOUNT_ID", "false") == "true",
              "SUPABASE_URL": os.environ.get("HAS_SUPABASE_URL", "false") == "true",
              "SUPABASE_ANON_KEY": os.environ.get("HAS_SUPABASE_ANON_KEY", "false") == "true",
              "SUPABASE_SERVICE_ROLE_KEY": os.environ.get("HAS_SUPABASE_SERVICE_ROLE_KEY", "false") == "true",
              "AUTO_FIX_TOKEN": os.environ.get("HAS_AUTO_FIX_TOKEN", "false") == "true",
          }

          missing = [k for k, v in checks.items() if not v]
          present = [k for k, v in checks.items() if v]

          print(f"Present ({len(present)}): {present}")
          if missing:
              print(f"MISSING ({len(missing)}): {missing}")

          status = "failed" if missing else "success"
          details = f"Missing secrets: {missing}" if missing else f"All {len(checks)} required secrets present"

          with open(os.environ.get("GITHUB_OUTPUT", "/dev/null"), "a") as f:
              f.write(f"status={status}\n")
              f.write(f"details={details}\n")

          if missing:
              import sys
              sys.exit(1)
          PYEOF

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Check 4: CI Validator Self-Test
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  check-validator-selftest:
    name: "Check: CI Validator Self-Test"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      status: ${{ steps.check.outputs.status }}
      details: ${{ steps.check.outputs.details }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Run CI validator against own codebase
        id: check
        run: |
          pip install pyyaml --quiet
          python3 tools/ci-validator/validate.py --report=/tmp/self-validation.json 2>&1 || true

          python3 << 'PYEOF'
          import json, os, sys

          report_path = "/tmp/self-validation.json"
          if not os.path.exists(report_path):
              print("::warning::Validation report not generated â€” validator may have crashed")
              with open(os.environ.get("GITHUB_OUTPUT", "/dev/null"), "a") as f:
                  f.write("status=warning\n")
                  f.write("details=Validator did not produce report\n")
              sys.exit(0)

          with open(report_path) as f:
              report = json.load(f)

          total_errors = sum(
              len([f for f in v.get("findings", []) if f.get("severity") == "error"])
              for v in report.values() if isinstance(v, dict)
          )
          total_warnings = sum(
              len([f for f in v.get("findings", []) if f.get("severity") == "warning"])
              for v in report.values() if isinstance(v, dict)
          )

          print(f"Validator self-test: {total_errors} errors, {total_warnings} warnings")

          status = "failed" if total_errors > 5 else ("warning" if total_errors > 0 else "success")
          details = f"{total_errors} errors, {total_warnings} warnings"

          with open(os.environ.get("GITHUB_OUTPUT", "/dev/null"), "a") as f:
              f.write(f"status={status}\n")
              f.write(f"details={details}\n")
          PYEOF

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Aggregate: Report & Auto-Repair
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  aggregate-and-repair:
    name: "Aggregate Results & Auto-Repair"
    needs:
      - check-workflow-integrity
      - check-strategy-coverage
      - check-secrets-presence
      - check-validator-selftest
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          token: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Compile health report
        id: report
        run: |
          python3 << 'PYEOF'
          import os

          checks = {
              "Workflow Integrity": ("${{ needs.check-workflow-integrity.outputs.status }}", "${{ needs.check-workflow-integrity.outputs.details }}"),
              "Strategy Coverage": ("${{ needs.check-strategy-coverage.outputs.status }}", "${{ needs.check-strategy-coverage.outputs.details }}"),
              "Secrets Presence": ("${{ needs.check-secrets-presence.outputs.status }}", "${{ needs.check-secrets-presence.outputs.details }}"),
              "Validator Self-Test": ("${{ needs.check-validator-selftest.outputs.status }}", "${{ needs.check-validator-selftest.outputs.details }}"),
          }

          icons = {"success": "âœ…", "warning": "âš ï¸", "failed": "âŒ", "": "â“"}
          lines = []
          failures = []
          for name, (status, details) in checks.items():
              icon = icons.get(status, "â“")
              lines.append(f"{icon} **{name}**: {status} â€” {details}")
              if status == "failed":
                  failures.append(name)

          overall = "HEALTHY" if not failures else f"DEGRADED ({len(failures)} failures)"
          print(f"\n{'='*60}")
          print(f"FRAMEWORK HEALTH: {overall}")
          print(f"{'='*60}")
          for line in lines:
              print(line.replace("**", ""))

          with open(os.environ.get("GITHUB_OUTPUT", "/dev/null"), "a") as f:
              f.write(f"overall={'healthy' if not failures else 'degraded'}\n")
              f.write(f"failures={','.join(failures)}\n")
              f.write(f"report={'|'.join(lines)}\n")
          PYEOF

      - name: Open health issue if degraded
        if: steps.report.outputs.overall == 'degraded'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          github-token: ${{ secrets.AUTO_FIX_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            // Check for existing open health issue to avoid duplicates
            const existing = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'framework-health',
              per_page: 5
            });

            if (existing.data.length > 0) {
              // Add comment to existing issue instead
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.data[0].number,
                body: `## ğŸ”„ Framework Health Check Update\n\n**Time:** ${new Date().toISOString()}\n**Run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n\n**Failures:** ${{ steps.report.outputs.failures }}\n\n${{ steps.report.outputs.report }}`
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `âš ï¸ [FRAMEWORK HEALTH] Degraded â€” ${new Date().toISOString().slice(0,10)}`,
                body: `## Framework Self-Maintenance Alert\n\n**Status:** DEGRADED\n**Time:** ${new Date().toISOString()}\n**Run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n\n**Failed Checks:** ${{ steps.report.outputs.failures }}\n\n### Details\n${{ steps.report.outputs.report }}\n\n### Auto-Repair\nThe framework will attempt auto-repair on the next scheduled run.\nIf the issue persists, manual intervention is required.`,
                labels: ['framework-health', 'automated']
              });
            }

      - name: Write structured audit log
        run: |
          echo "{\"timestamp\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"check\":\"framework-self-maintenance\",\"overall\":\"${{ steps.report.outputs.overall }}\",\"failures\":\"${{ steps.report.outputs.failures }}\",\"sha\":\"${{ github.sha }}\"}" \
            >> /tmp/framework-health-audit.log
          cat /tmp/framework-health-audit.log

      - name: Summary
        run: |
          echo "## Framework Self-Maintenance Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Overall:** ${{ steps.report.outputs.overall }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.report.outputs.report }}" | tr '|' '\n' >> $GITHUB_STEP_SUMMARY
