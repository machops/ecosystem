name: Security Alert Auto-Remediation

on:
  schedule:
    # Run daily at 03:00 UTC
    - cron: '0 3 * * *'
  push:
    branches: [main]
    paths:
      - 'package.json'
      - 'pnpm-lock.yaml'
      - '**/*.md'
      - 'helm/**'
      - 'k8s/**'
      - 'scripts/**'
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  security-events: read

concurrency:
  group: security-alert-remediation
  cancel-in-progress: true

jobs:
  # ═══════════════════════════════════════════════════════════════
  # Job 1: Scan for hardcoded secrets in source files
  # ═══════════════════════════════════════════════════════════════
  secret-scan-remediation:
    name: Secret Scanning Remediation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 1

      - name: Scan for remaining hardcoded secrets
        id: scan
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          python3 - << 'PYEOF'
          import subprocess, re, json, os

          # Patterns that indicate real secrets (not placeholders)
          SECRET_PATTERNS = [
              r'eyJhbGciOi[A-Za-z0-9_-]{20,}',           # JWT tokens
              r'-----BEGIN (PRIVATE|RSA) KEY-----',         # Private keys
              r'sb_publishable_[A-Za-z0-9_-]{10,}',        # Supabase publishable keys
              r'sb_secret_[A-Za-z0-9_-]{10,}',             # Supabase secret keys
              r'postgresql://[^:]+:[^@]{4,}@[^\s"]+',      # Postgres connection strings with real passwords
              r'ghu_[A-Za-z0-9]{36}',                      # GitHub tokens
              r'ghp_[A-Za-z0-9]{36}',                      # GitHub PATs
              r'sk-[A-Za-z0-9]{32,}',                      # OpenAI-style API keys
          ]

          # Placeholder patterns to exclude (these are safe)
          SAFE_PATTERNS = [
              'YOUR_', 'INJECT_FROM_', 'REDACTED_', 'PLACEHOLDER',
              'changeme', 'example', 'YOUR_PASSWORD', 'YOUR_SECURE_PASSWORD',
          ]

          findings = []
          exclude_dirs = {'.git', 'node_modules', '.next', 'dist', '__pycache__'}

          for root, dirs, files in os.walk('.'):
              dirs[:] = [d for d in dirs if d not in exclude_dirs]
              for fname in files:
                  if not fname.endswith(('.md', '.yaml', '.yml', '.py', '.sh', '.json', '.qyaml', '.js', '.ts', '.env')):
                      continue
                  fpath = os.path.join(root, fname)
                  try:
                      with open(fpath, 'r', errors='ignore') as f:
                          content = f.read()
                      for pattern in SECRET_PATTERNS:
                          for match in re.finditer(pattern, content):
                              matched_text = match.group(0)[:50]
                              # Skip if it's a known placeholder
                              if any(safe in matched_text for safe in SAFE_PATTERNS):
                                  continue
                              line_num = content[:match.start()].count('\n') + 1
                              findings.append({
                                  'file': fpath,
                                  'line': line_num,
                                  'pattern': pattern[:30],
                                  'preview': matched_text[:30] + '...'
                              })
                  except Exception:
                      pass

          if findings:
              print(f"::warning::Found {len(findings)} potential hardcoded secrets")
              for f in findings[:10]:
                  print(f"  {f['file']}:{f['line']} — {f['preview']}")
              with open('/tmp/secret-findings.json', 'w') as out:
                  json.dump(findings, out, indent=2)
              # Set output for issue creation
              print(f"findings_count={len(findings)}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as gh:
                  gh.write(f"findings_count={len(findings)}\n")
          else:
              print("No hardcoded secrets found in source files")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as gh:
                  gh.write("findings_count=0\n")
          PYEOF

      - name: Create issue if secrets found (with 48h dedup)
        if: steps.scan.outputs.findings_count != '0'
        env:
          GITHUB_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          FINDINGS_COUNT: ${{ steps.scan.outputs.findings_count }}
        run: |
          ISSUE_TITLE="Security: Hardcoded Secrets Detected in Source"
          DEDUP_CUTOFF=$(date -u -d '48 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "2020-01-01T00:00:00Z")

          EXISTING_OPEN=$(gh issue list --repo "$REPO" --search "\"$ISSUE_TITLE\" in:title" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")
          EXISTING_CLOSED=$(gh issue list --repo "$REPO" --search "\"$ISSUE_TITLE\" in:title" --state closed --json number,closedAt --jq ".[] | select(.closedAt > \"$DEDUP_CUTOFF\") | .number" 2>/dev/null | head -1 || echo "")

          if [ -n "$EXISTING_OPEN" ]; then
            echo "Issue already open: #$EXISTING_OPEN"
            exit 0
          fi
          if [ -n "$EXISTING_CLOSED" ]; then
            echo "Issue recently closed within 48h: #$EXISTING_CLOSED"
            exit 0
          fi

          BODY="## Hardcoded Secrets Detected

          The automated security scan found **$FINDINGS_COUNT** potential hardcoded secrets in source files.

          ### Action Required
          1. Replace all hardcoded secrets with environment variable references or \`INJECT_FROM_K8S_SECRET\` placeholders
          2. Rotate any exposed credentials
          3. Verify via \`security-gates.yaml\` Gitleaks scan

          ### Automation Context
          - **Scan**: security-alert-remediation.yaml
          - **Timestamp**: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          gh issue create --repo "$REPO" \
            --title "$ISSUE_TITLE" \
            --body "$BODY" \
            --label "security,auto-repair" 2>/dev/null || echo "Failed to create issue"

  # ═══════════════════════════════════════════════════════════════
  # Job 2: Check dependency vulnerabilities and auto-fix
  # ═══════════════════════════════════════════════════════════════
  dependency-vulnerability-check:
    name: Dependency Vulnerability Check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020  # v4.4.0
        with:
          node-version: '20'

      - name: Check for vulnerable dependencies
        id: vuln_check
        run: |
          if [ -f "package.json" ]; then
            npm install -g pnpm@9 2>/dev/null || true
            pnpm install --frozen-lockfile 2>/dev/null || pnpm install 2>/dev/null || true
            pnpm audit --audit-level=high 2>&1 | tee /tmp/audit-output.txt || true
            HIGH_COUNT=$(grep -c "high\|critical" /tmp/audit-output.txt 2>/dev/null || true)
            HIGH_COUNT=${HIGH_COUNT:-0}
            echo "high_count=$HIGH_COUNT" >> "$GITHUB_OUTPUT"
          else
            echo "high_count=0" >> "$GITHUB_OUTPUT"
          fi

      - name: Create issue for high vulnerabilities (with 48h dedup)
        if: steps.vuln_check.outputs.high_count != '0'
        env:
          GITHUB_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          HIGH_COUNT: ${{ steps.vuln_check.outputs.high_count }}
        run: |
          ISSUE_TITLE="Security: High/Critical Dependency Vulnerabilities"
          DEDUP_CUTOFF=$(date -u -d '48 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "2020-01-01T00:00:00Z")

          EXISTING_OPEN=$(gh issue list --repo "$REPO" --search "\"$ISSUE_TITLE\" in:title" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")
          EXISTING_CLOSED=$(gh issue list --repo "$REPO" --search "\"$ISSUE_TITLE\" in:title" --state closed --json number,closedAt --jq ".[] | select(.closedAt > \"$DEDUP_CUTOFF\") | .number" 2>/dev/null | head -1 || echo "")

          if [ -n "$EXISTING_OPEN" ] || [ -n "$EXISTING_CLOSED" ]; then
            echo "Issue already exists or recently closed — skipping"
            exit 0
          fi

          BODY="## Dependency Vulnerabilities Detected

          Found **$HIGH_COUNT** high/critical vulnerability indicators in dependency audit.

          ### Action Required
          1. Run \`pnpm audit\` to see full details
          2. Update vulnerable packages or add \`pnpm.overrides\` for transitive dependencies
          3. Re-run \`pnpm audit\` to verify resolution

          ### Automation Context
          - **Scan**: security-alert-remediation.yaml
          - **Timestamp**: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          gh issue create --repo "$REPO" \
            --title "$ISSUE_TITLE" \
            --body "$BODY" \
            --label "security,dependencies,auto-repair" 2>/dev/null || echo "Failed to create issue"

  # ═══════════════════════════════════════════════════════════════
  # Job 3: Workflow YAML health check
  # ═══════════════════════════════════════════════════════════════
  workflow-health-check:
    name: Workflow YAML Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Validate all workflow YAML files
        id: yaml_check
        run: |
          pip install pyyaml -q 2>/dev/null
          python3 - << 'PYEOF'
          import yaml, glob, os

          errors = []
          for wf_file in sorted(glob.glob(".github/workflows/*.yaml") + glob.glob(".github/workflows/*.yml")):
              try:
                  with open(wf_file) as f:
                      data = yaml.safe_load(f)
                  if not data:
                      errors.append(f"{wf_file}: empty or invalid")
                  elif 'jobs' not in data:
                      errors.append(f"{wf_file}: missing 'jobs' key")
                  else:
                      # Check for corrupted runs-on patterns
                      content = open(wf_file).read()
                      if 'workflow_dispatch: ubuntu-latest' in content:
                          errors.append(f"{wf_file}: corrupted runs-on pattern detected")
                      # Check for unpinned actions
                      import re
                      unpinned = re.findall(r'uses:\s+([^@\n]+)@(?![\da-f]{40})[^\n]+', content)
                      for u in unpinned:
                          errors.append(f"{wf_file}: unpinned action: {u.strip()}")
              except yaml.YAMLError as e:
                  errors.append(f"{wf_file}: YAML parse error: {e}")
              except Exception as e:
                  errors.append(f"{wf_file}: {e}")

          if errors:
              print(f"Found {len(errors)} workflow issues:")
              for e in errors:
                  print(f"  - {e}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as gh:
                  gh.write(f"error_count={len(errors)}\n")
          else:
              print("All workflow YAML files are valid")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as gh:
                  gh.write("error_count=0\n")
          PYEOF

      - name: Create issue for workflow errors (with 48h dedup)
        if: steps.yaml_check.outputs.error_count != '0'
        env:
          GITHUB_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          ERROR_COUNT: ${{ steps.yaml_check.outputs.error_count }}
        run: |
          ISSUE_TITLE="Security: Workflow YAML Validation Errors"
          DEDUP_CUTOFF=$(date -u -d '48 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "2020-01-01T00:00:00Z")

          EXISTING_OPEN=$(gh issue list --repo "$REPO" --search "\"$ISSUE_TITLE\" in:title" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")
          EXISTING_CLOSED=$(gh issue list --repo "$REPO" --search "\"$ISSUE_TITLE\" in:title" --state closed --json number,closedAt --jq ".[] | select(.closedAt > \"$DEDUP_CUTOFF\") | .number" 2>/dev/null | head -1 || echo "")

          if [ -n "$EXISTING_OPEN" ] || [ -n "$EXISTING_CLOSED" ]; then
            echo "Issue already exists or recently closed — skipping"
            exit 0
          fi

          BODY="## Workflow YAML Validation Errors

          Found **$ERROR_COUNT** issues in GitHub Actions workflow files.

          ### Common Issues
          - YAML syntax errors (corrupted \`runs-on:\` patterns)
          - Unpinned action versions (SLSA compliance violation)
          - Missing required keys

          ### Automation Context
          - **Scan**: security-alert-remediation.yaml
          - **Timestamp**: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          gh issue create --repo "$REPO" \
            --title "$ISSUE_TITLE" \
            --body "$BODY" \
            --label "security,ci-failure,auto-repair" 2>/dev/null || echo "Failed to create issue"

  # ═══════════════════════════════════════════════════════════════
  # Job 4: Security alert summary
  # ═══════════════════════════════════════════════════════════════
  security-summary:
    name: Security Summary
    needs: [secret-scan-remediation, dependency-vulnerability-check, workflow-health-check]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Generate summary
        env:
          SECRET_SCAN: ${{ needs.secret-scan-remediation.result }}
          DEP_CHECK: ${{ needs.dependency-vulnerability-check.result }}
          WF_CHECK: ${{ needs.workflow-health-check.result }}
        run: |
          echo "## Security Alert Remediation Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Check | Status |" >> "$GITHUB_STEP_SUMMARY"
          echo "|-------|--------|" >> "$GITHUB_STEP_SUMMARY"

          for check in "Secret Scan:$SECRET_SCAN" "Dependency Vulnerabilities:$DEP_CHECK" "Workflow Health:$WF_CHECK"; do
            NAME="${check%%:*}"
            RESULT="${check##*:}"
            if [ "$RESULT" = "success" ]; then
              echo "| $NAME | PASS |" >> "$GITHUB_STEP_SUMMARY"
            elif [ "$RESULT" = "skipped" ]; then
              echo "| $NAME | SKIP |" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "| $NAME | FAIL |" >> "$GITHUB_STEP_SUMMARY"
            fi
          done

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "Scan completed at: $(date -u '+%Y-%m-%d %H:%M UTC')" >> "$GITHUB_STEP_SUMMARY"
