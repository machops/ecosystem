#!/usr/bin/env python3
"""
PR Blocked Response — Diagnose and Respond
eco-base autonomous bot: detects blocked PRs, diagnoses root cause,
attempts auto-fix, escalates to Issue if manual intervention needed.
"""
import os
import json
import subprocess
import sys
import re

REPO = os.environ.get("REPO", "indestructibleorg/eco-base")
SPECIFIC_PR = os.environ.get("SPECIFIC_PR", "").strip()


def gh_run(args, **kwargs):
    return subprocess.run(["gh"] + args, capture_output=True, text=True, **kwargs)


def get_open_prs():
    if SPECIFIC_PR:
        r = gh_run(["pr", "view", SPECIFIC_PR, "--repo", REPO, "--json",
                    "number,title,state,mergeable,mergeStateStatus,statusCheckRollup,labels,headRefName,author"])
        return [json.loads(r.stdout)] if r.returncode == 0 and r.stdout.strip() else []
    r = gh_run(["pr", "list", "--repo", REPO, "--state", "open", "--limit", "50",
                "--json", "number,title,state,mergeable,mergeStateStatus,statusCheckRollup,labels,headRefName,author"])
    return json.loads(r.stdout) if r.returncode == 0 and r.stdout.strip() else []


def fix_circleci():
    """Create .circleci/config.yml to suppress CircleCI false positive."""
    path = ".circleci/config.yml"
    os.makedirs(".circleci", exist_ok=True)
    if not os.path.exists(path):
        with open(path, "w") as f:
            f.write(
                "version: 2.1\n"
                "# eco-base uses GitHub Actions for CI/CD.\n"
                "# This file exists to prevent CircleCI from parsing\n"
                "# GitHub Actions workflow files as CircleCI config.\n"
            )
        print("  [AUTO-FIX] Created .circleci/config.yml")
        return True
    return False


def fix_dependabot_yaml():
    """Fix invalid Docker ignore version rules in dependabot.yml."""
    path = ".github/dependabot.yml"
    if not os.path.exists(path):
        return False
    with open(path, "r") as f:
        content = f.read()

    # Remove invalid Docker version-based ignore rules
    patterns = [
        r"\n    ignore:\n      # Python [^\n]+\n      - dependency-name: \"python\"\n        versions: \[[^\]]+\]\n      # Node [^\n]+\n      - dependency-name: \"node\"\n        versions: \[[^\]]+\]",
        r"\n    ignore:\n      - dependency-name: \"node\"\n        versions: \[[^\]]+\]",
        r"\n    ignore:\n      - dependency-name: \"python\"\n        versions: \[[^\]]+\]",
    ]
    fixed = content
    for p in patterns:
        fixed = re.sub(p, "", fixed)

    if fixed != content:
        with open(path, "w") as f:
            f.write(fixed)
        print("  [AUTO-FIX] Removed invalid Docker ignore version rules from dependabot.yml")
        return True
    return False


def trigger_rebase(pr_num):
    r = gh_run(["pr", "comment", str(pr_num), "--repo", REPO,
                "--body", "@dependabot rebase"])
    ok = r.returncode == 0
    print(f"  [AUTO-FIX] @dependabot rebase on #{pr_num}: {'OK' if ok else r.stderr[:60]}")
    return ok


def add_label(pr_num, label):
    r = gh_run(["pr", "edit", str(pr_num), "--repo", REPO, "--add-label", label])
    if r.returncode == 0:
        print(f"  [LABEL] Added '{label}' to PR #{pr_num}")


def post_diagnosis_comment(pr_num, merge_status, failing, skipped, diagnosis,
                           auto_fixable, manual_required):
    # Check for existing diagnosis comment
    r = gh_run(["pr", "view", str(pr_num), "--repo", REPO, "--json", "comments"])
    if r.returncode == 0 and r.stdout.strip():
        comments = json.loads(r.stdout).get("comments", [])
        if any("Autonomous Bot" in c.get("body", "") and "PR Blocked Diagnosis" in c.get("body", "")
               for c in comments):
            print(f"  [COMMENT] Diagnosis comment already exists for #{pr_num}, skipping")
            return

    diagnosis_lines = "\n".join(f"- {d}" for d in diagnosis) if diagnosis else "- No specific diagnosis"
    auto_fix_lines = "\n".join(f"- `{a}`" for a in auto_fixable) if auto_fixable else "- None"
    manual_lines = "\n".join(f"- `{m}`" for m in manual_required) if manual_required else "- None"
    failing_lines = "\n".join(f"- X `{f['name']}`" for f in failing) if failing else "- None"
    skipped_lines = "\n".join(f"- skip `{s}`" for s in skipped) if skipped else "- None"

    body = (
        f"## Autonomous Bot: PR Blocked Diagnosis\n\n"
        f"PR #{pr_num} is currently blocked (`{merge_status}`).\n\n"
        f"### Root Cause Analysis\n{diagnosis_lines}\n\n"
        f"### Auto-Fix Actions Taken\n{auto_fix_lines}\n\n"
        f"### Requires Manual Review\n{manual_lines}\n\n"
        f"### Failing Checks\n{failing_lines}\n\n"
        f"### Skipped Checks (expected)\n{skipped_lines}\n\n"
        f"---\n"
        f"*Auto-generated by PR Blocked Response workflow. "
        f"If the issue persists after auto-fix, please review the failing checks above.*\n"
    )
    r = gh_run(["pr", "comment", str(pr_num), "--repo", REPO, "--body", body])
    print(f"  [COMMENT] Posted diagnosis: {'OK' if r.returncode == 0 else r.stderr[:80]}")


def create_tracking_issue(pr_num, pr_title, pr_branch, merge_status, manual_required, diagnosis):
    # Check if issue already exists
    r = gh_run(["issue", "list", "--repo", REPO, "--state", "open",
                "--label", "blocked", "--json", "number,title"])
    existing = json.loads(r.stdout) if r.returncode == 0 and r.stdout.strip() else []
    if any(f"PR #{pr_num}" in i["title"] for i in existing):
        print(f"  [ISSUE] Tracking issue for #{pr_num} already exists")
        return

    diagnosis_lines = "\n".join(f"- {d}" for d in diagnosis)
    manual_lines = "\n".join(f"- `{m}`" for m in manual_required)
    title = f"[Auto] PR #{pr_num} blocked: {', '.join(manual_required[:3])}"
    body = (
        f"## PR #{pr_num} is blocked and requires manual intervention\n\n"
        f"**PR:** https://github.com/{REPO}/pull/{pr_num}\n"
        f"**Title:** {pr_title}\n"
        f"**Branch:** `{pr_branch}`\n"
        f"**Block reason:** `{merge_status}`\n\n"
        f"### Failing Checks (require manual fix)\n{manual_lines}\n\n"
        f"### Diagnosis\n{diagnosis_lines}\n\n"
        f"### Next Steps\n"
        f"1. Review the failing checks in the PR\n"
        f"2. Fix the root cause in the source branch\n"
        f"3. Push the fix to trigger a new CI run\n"
        f"4. The PR will auto-merge once all required checks pass\n\n"
        f"---\n*Auto-created by PR Blocked Response workflow*\n"
    )
    r = gh_run(["issue", "create", "--repo", REPO,
                "--title", title, "--body", body,
                "--label", "blocked,needs-attention"])
    print(f"  [ISSUE] Created: {'OK - ' + r.stdout.strip() if r.returncode == 0 else r.stderr[:80]}")


def commit_auto_fixes():
    r = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True)
    if not r.stdout.strip():
        print("\n[GIT] No auto-fixes to commit")
        return
    subprocess.run(["git", "config", "user.email", "bot@eco-base.dev"])
    subprocess.run(["git", "config", "user.name", "eco-base-bot"])
    # Best practice: never push directly to main — create branch → PR → auto-merge
    import time
    branch = f"bot/auto-fix-blocked-{int(time.time())}"
    subprocess.run(["git", "checkout", "-b", branch])
    subprocess.run(["git", "add", "-A"])
    subprocess.run(["git", "commit", "-m",
                    "fix(bot): auto-fix PR blocked issues\n\n"
                    "- Added .circleci/config.yml to suppress CircleCI false positive\n"
                    "- Fixed dependabot.yml invalid Docker ignore version rules"])
    r_push = subprocess.run(["git", "push", "origin", branch], capture_output=True, text=True)
    if r_push.returncode != 0:
        print(f"\n[GIT] Push failed: {r_push.stderr[:80]}")
        return
    # Create PR and enable auto-merge
    r_pr = subprocess.run([
        "gh", "pr", "create",
        "--title", "fix(bot): auto-fix PR blocked issues",
        "--body", "Automated fix by PR Blocked Response workflow.\n\n"
                  "- Added .circleci/config.yml to suppress CircleCI false positive\n"
                  "- Fixed dependabot.yml invalid Docker ignore version rules\n\n"
                  "This PR was created automatically and will auto-merge once required checks pass.",
        "--label", "automated,bot-pr",
        "--base", "main",
        "--head", branch
    ], capture_output=True, text=True)
    if r_pr.returncode == 0:
        pr_url = r_pr.stdout.strip()
        print(f"\n[GIT] Created PR: {pr_url}")
        subprocess.run(["gh", "pr", "merge", pr_url, "--auto", "--squash"])
        print("[GIT] Auto-merge enabled")
    else:
        print(f"\n[GIT] PR creation failed: {r_pr.stderr[:80]}")


def main():
    prs = get_open_prs()
    print(f"Scanning {len(prs)} open PRs...")

    blocked = [p for p in prs if p.get("mergeStateStatus") in ("BLOCKED", "DIRTY", "UNSTABLE")]
    print(f"Found {len(blocked)} blocked PRs: {[p['number'] for p in blocked]}")

    any_auto_fix = False

    for pr in blocked:
        pr_num = pr["number"]
        pr_title = pr["title"]
        pr_branch = pr.get("headRefName", "")
        merge_status = pr.get("mergeStateStatus", "BLOCKED")
        checks = pr.get("statusCheckRollup", [])
        labels = [l["name"] for l in pr.get("labels", [])]

        print(f"\n=== PR #{pr_num}: {pr_title[:60]} ===")
        print(f"  MergeStateStatus: {merge_status}")

        failing = [c for c in checks
                   if c.get("conclusion") in ("FAILURE", "failure", "ERROR", "error")]
        skipped = [c.get("name") or c.get("context", "?") for c in checks
                   if c.get("conclusion") == "SKIPPED" or c.get("status") == "SKIPPED"]

        print(f"  Failing: {[f.get('name') for f in failing]}")
        print(f"  Skipped: {skipped}")

        diagnosis = []
        auto_fixable = []
        manual_required = []

        for f in failing:
            name = f.get("name", "")
            if name == ".github/dependabot.yml":
                diagnosis.append("dependabot.yml has invalid syntax (Docker ignore version format)")
                auto_fixable.append("dependabot.yml")
            elif name == "CircleCI Pipeline":
                diagnosis.append("CircleCI false positive (not a CircleCI project)")
                auto_fixable.append("circleci")
            elif any(k in name.lower() for k in ("yaml-lint", "validate", "lint")):
                diagnosis.append(f"Workflow validation failed: {name}")
                auto_fixable.append("workflow-lint")
            elif any(k in name.lower() for k in ("test", "spec")):
                diagnosis.append(f"Tests failing: {name}")
                manual_required.append(name)
            elif any(k in name.lower() for k in ("security", "scan", "cve", "grype")):
                diagnosis.append(f"Security scan failed: {name}")
                manual_required.append(name)
            else:
                diagnosis.append(f"Unknown failure: {name}")
                manual_required.append(name)

        if merge_status == "DIRTY":
            diagnosis.append("Merge conflict with main branch")
            auto_fixable.append("rebase")

        # Execute auto-fixes
        if "circleci" in auto_fixable:
            if fix_circleci():
                any_auto_fix = True

        if "dependabot.yml" in auto_fixable:
            if fix_dependabot_yaml():
                any_auto_fix = True

        if "rebase" in auto_fixable:
            trigger_rebase(pr_num)

        # Label management
        if failing and "blocked" not in labels:
            add_label(pr_num, "blocked")

        if manual_required and "human-review-required" not in labels:
            add_label(pr_num, "human-review-required")

        # Post diagnosis comment
        if failing:
            post_diagnosis_comment(pr_num, merge_status, failing, skipped,
                                   diagnosis, auto_fixable, manual_required)

        # Create tracking issue for manual-required items
        if manual_required:
            create_tracking_issue(pr_num, pr_title, pr_branch, merge_status,
                                  manual_required, diagnosis)

    # Commit all auto-fixes to main
    if any_auto_fix:
        commit_auto_fixes()

    print("\nDone! PR Blocked Response complete.")


if __name__ == "__main__":
    main()
